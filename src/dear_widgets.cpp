#include <dear_widgets.h>

#include "common.h"

#ifdef DEAR_WIDGETS_TESSELATION
#include <map>
#endif

namespace ImWidgets
{
ImGlobalData GlobalData;

//////////////////////////////////////////////////////////////////////////
// Data
//////////////////////////////////////////////////////////////////////////
#define ImSqrt3 1.7320508075688772935274463415059f

static const float DRAGDROP_HOLD_TO_OPEN_TIMER = 0.70f; // COPY PASTED FROM imgui_widgets.cpp
// static const float DRAG_MOUSE_THRESHOLD_FACTOR = 0.50f; // COPY PASTED FROM imgui_widgets.cpp

static float s_CIE_1931_2deg_min = 360.0f;
static float s_CIE_1931_2deg_max = 830.0f;
#define s_CIE_1931_2deg_samplesCount 471
static float s_CIE_1931_2deg_X[] = {
    0.000129900000f, 0.000145847000f, 0.000163802100f, 0.000184003700f, 0.000206690200f, 0.000232100000f,
    0.000260728000f, 0.000293075000f, 0.000329388000f, 0.000369914000f, 0.000414900000f, 0.000464158700f,
    0.000518986000f, 0.000581854000f, 0.000655234700f, 0.000741600000f, 0.000845029600f, 0.000964526800f,
    0.001094949000f, 0.001231154000f, 0.001368000000f, 0.001502050000f, 0.001642328000f, 0.001802382000f,
    0.001995757000f, 0.002236000000f, 0.002535385000f, 0.002892603000f, 0.003300829000f, 0.003753236000f,
    0.004243000000f, 0.004762389000f, 0.005330048000f, 0.005978712000f, 0.006741117000f, 0.007650000000f,
    0.008751373000f, 0.010028880000f, 0.011421700000f, 0.012869010000f, 0.014310000000f, 0.015704430000f,
    0.017147440000f, 0.018781220000f, 0.020748010000f, 0.023190000000f, 0.026207360000f, 0.029782480000f,
    0.033880920000f, 0.038468240000f, 0.043510000000f, 0.048995600000f, 0.055022600000f, 0.061718800000f,
    0.069212000000f, 0.077630000000f, 0.086958110000f, 0.097176720000f, 0.108406300000f, 0.120767200000f,
    0.134380000000f, 0.149358200000f, 0.165395700000f, 0.181983100000f, 0.198611000000f, 0.214770000000f,
    0.230186800000f, 0.244879700000f, 0.258777300000f, 0.271807900000f, 0.283900000000f, 0.294943800000f,
    0.304896500000f, 0.313787300000f, 0.321645400000f, 0.328500000000f, 0.334351300000f, 0.339210100000f,
    0.343121300000f, 0.346129600000f, 0.348280000000f, 0.349599900000f, 0.350147400000f, 0.350013000000f,
    0.349287000000f, 0.348060000000f, 0.346373300000f, 0.344262400000f, 0.341808800000f, 0.339094100000f,
    0.336200000000f, 0.333197700000f, 0.330041100000f, 0.326635700000f, 0.322886800000f, 0.318700000000f,
    0.314025100000f, 0.308884000000f, 0.303290400000f, 0.297257900000f, 0.290800000000f, 0.283970100000f,
    0.276721400000f, 0.268917800000f, 0.260422700000f, 0.251100000000f, 0.240847500000f, 0.229851200000f,
    0.218407200000f, 0.206811500000f, 0.195360000000f, 0.184213600000f, 0.173327300000f, 0.162688100000f,
    0.152283300000f, 0.142100000000f, 0.132178600000f, 0.122569600000f, 0.113275200000f, 0.104297900000f,
    0.095640000000f, 0.087299550000f, 0.079308040000f, 0.071717760000f, 0.064580990000f, 0.057950010000f,
    0.051862110000f, 0.046281520000f, 0.041150880000f, 0.036412830000f, 0.032010000000f, 0.027917200000f,
    0.024144400000f, 0.020687000000f, 0.017540400000f, 0.014700000000f, 0.012161790000f, 0.009919960000f,
    0.007967240000f, 0.006296346000f, 0.004900000000f, 0.003777173000f, 0.002945320000f, 0.002424880000f,
    0.002236293000f, 0.002400000000f, 0.002925520000f, 0.003836560000f, 0.005174840000f, 0.006982080000f,
    0.009300000000f, 0.012149490000f, 0.015535880000f, 0.019477520000f, 0.023992770000f, 0.029100000000f,
    0.034814850000f, 0.041120160000f, 0.047985040000f, 0.055378610000f, 0.063270000000f, 0.071635010000f,
    0.080462240000f, 0.089739960000f, 0.099456450000f, 0.109600000000f, 0.120167400000f, 0.131114500000f,
    0.142367900000f, 0.153854200000f, 0.165500000000f, 0.177257100000f, 0.189140000000f, 0.201169400000f,
    0.213365800000f, 0.225749900000f, 0.238320900000f, 0.251066800000f, 0.263992200000f, 0.277101700000f,
    0.290400000000f, 0.303891200000f, 0.317572600000f, 0.331438400000f, 0.345482800000f, 0.359700000000f,
    0.374083900000f, 0.388639600000f, 0.403378400000f, 0.418311500000f, 0.433449900000f, 0.448795300000f,
    0.464336000000f, 0.480064000000f, 0.495971300000f, 0.512050100000f, 0.528295900000f, 0.544691600000f,
    0.561209400000f, 0.577821500000f, 0.594500000000f, 0.611220900000f, 0.627975800000f, 0.644760200000f,
    0.661569700000f, 0.678400000000f, 0.695239200000f, 0.712058600000f, 0.728828400000f, 0.745518800000f,
    0.762100000000f, 0.778543200000f, 0.794825600000f, 0.810926400000f, 0.826824800000f, 0.842500000000f,
    0.857932500000f, 0.873081600000f, 0.887894400000f, 0.902318100000f, 0.916300000000f, 0.929799500000f,
    0.942798400000f, 0.955277600000f, 0.967217900000f, 0.978600000000f, 0.989385600000f, 0.999548800000f,
    1.009089200000f, 1.018006400000f, 1.026300000000f, 1.033982700000f, 1.040986000000f, 1.047188000000f,
    1.052466700000f, 1.056700000000f, 1.059794400000f, 1.061799200000f, 1.062806800000f, 1.062909600000f,
    1.062200000000f, 1.060735200000f, 1.058443600000f, 1.055224400000f, 1.050976800000f, 1.045600000000f,
    1.039036900000f, 1.031360800000f, 1.022666200000f, 1.013047700000f, 1.002600000000f, 0.991367500000f,
    0.979331400000f, 0.966491600000f, 0.952847900000f, 0.938400000000f, 0.923194000000f, 0.907244000000f,
    0.890502000000f, 0.872920000000f, 0.854449900000f, 0.835084000000f, 0.814946000000f, 0.794186000000f,
    0.772954000000f, 0.751400000000f, 0.729583600000f, 0.707588800000f, 0.685602200000f, 0.663810400000f,
    0.642400000000f, 0.621514900000f, 0.601113800000f, 0.581105200000f, 0.561397700000f, 0.541900000000f,
    0.522599500000f, 0.503546400000f, 0.484743600000f, 0.466193900000f, 0.447900000000f, 0.429861300000f,
    0.412098000000f, 0.394644000000f, 0.377533300000f, 0.360800000000f, 0.344456300000f, 0.328516800000f,
    0.313019200000f, 0.298001100000f, 0.283500000000f, 0.269544800000f, 0.256118400000f, 0.243189600000f,
    0.230727200000f, 0.218700000000f, 0.207097100000f, 0.195923200000f, 0.185170800000f, 0.174832300000f,
    0.164900000000f, 0.155366700000f, 0.146230000000f, 0.137490000000f, 0.129146700000f, 0.121200000000f,
    0.113639700000f, 0.106465000000f, 0.099690440000f, 0.093330610000f, 0.087400000000f, 0.081900960000f,
    0.076804280000f, 0.072077120000f, 0.067686640000f, 0.063600000000f, 0.059806850000f, 0.056282160000f,
    0.052971040000f, 0.049818610000f, 0.046770000000f, 0.043784050000f, 0.040875360000f, 0.038072640000f,
    0.035404610000f, 0.032900000000f, 0.030564190000f, 0.028380560000f, 0.026344840000f, 0.024452750000f,
    0.022700000000f, 0.021084290000f, 0.019599880000f, 0.018237320000f, 0.016987170000f, 0.015840000000f,
    0.014790640000f, 0.013831320000f, 0.012948680000f, 0.012129200000f, 0.011359160000f, 0.010629350000f,
    0.009938846000f, 0.009288422000f, 0.008678854000f, 0.008110916000f, 0.007582388000f, 0.007088746000f,
    0.006627313000f, 0.006195408000f, 0.005790346000f, 0.005409826000f, 0.005052583000f, 0.004717512000f,
    0.004403507000f, 0.004109457000f, 0.003833913000f, 0.003575748000f, 0.003334342000f, 0.003109075000f,
    0.002899327000f, 0.002704348000f, 0.002523020000f, 0.002354168000f, 0.002196616000f, 0.002049190000f,
    0.001910960000f, 0.001781438000f, 0.001660110000f, 0.001546459000f, 0.001439971000f, 0.001340042000f,
    0.001246275000f, 0.001158471000f, 0.001076430000f, 0.000999949300f, 0.000928735800f, 0.000862433200f,
    0.000800750300f, 0.000743396000f, 0.000690078600f, 0.000640515600f, 0.000594502100f, 0.000551864600f,
    0.000512429000f, 0.000476021300f, 0.000442453600f, 0.000411511700f, 0.000382981400f, 0.000356649100f,
    0.000332301100f, 0.000309758600f, 0.000288887100f, 0.000269539400f, 0.000251568200f, 0.000234826100f,
    0.000219171000f, 0.000204525800f, 0.000190840500f, 0.000178065400f, 0.000166150500f, 0.000155023600f,
    0.000144621900f, 0.000134909800f, 0.000125852000f, 0.000117413000f, 0.000109551500f, 0.000102224500f,
    0.000095394450f, 0.000089023900f, 0.000083075270f, 0.000077512690f, 0.000072313040f, 0.000067457780f,
    0.000062928440f, 0.000058706520f, 0.000054770280f, 0.000051099180f, 0.000047676540f, 0.000044485670f,
    0.000041509940f, 0.000038733240f, 0.000036142030f, 0.000033723520f, 0.000031464870f, 0.000029353260f,
    0.000027375730f, 0.000025524330f, 0.000023793760f, 0.000022178700f, 0.000020673830f, 0.000019272260f,
    0.000017966400f, 0.000016749910f, 0.000015616480f, 0.000014559770f, 0.000013573870f, 0.000012654360f,
    0.000011797230f, 0.000010998440f, 0.000010253980f, 0.000009559646f, 0.000008912044f, 0.000008308358f,
    0.000007745769f, 0.000007221456f, 0.000006732475f, 0.000006276423f, 0.000005851304f, 0.000005455118f,
    0.000005085868f, 0.000004741466f, 0.000004420236f, 0.000004120783f, 0.000003841716f, 0.000003581652f,
    0.000003339127f, 0.000003112949f, 0.000002902121f, 0.000002705645f, 0.000002522525f, 0.000002351726f,
    0.000002192415f, 0.000002043902f, 0.000001905497f, 0.000001776509f, 0.000001656215f, 0.000001544022f,
    0.000001439440f, 0.000001341977f, 0.000001251141f};
static float s_CIE_1931_2deg_Y[] = {
    0.000003917000f, 0.000004393581f, 0.000004929604f, 0.000005532136f, 0.000006208245f, 0.000006965000f,
    0.000007813219f, 0.000008767336f, 0.000009839844f, 0.000011043230f, 0.000012390000f, 0.000013886410f,
    0.000015557280f, 0.000017442960f, 0.000019583750f, 0.000022020000f, 0.000024839650f, 0.000028041260f,
    0.000031531040f, 0.000035215210f, 0.000039000000f, 0.000042826400f, 0.000046914600f, 0.000051589600f,
    0.000057176400f, 0.000064000000f, 0.000072344210f, 0.000082212240f, 0.000093508160f, 0.000106136100f,
    0.000120000000f, 0.000134984000f, 0.000151492000f, 0.000170208000f, 0.000191816000f, 0.000217000000f,
    0.000246906700f, 0.000281240000f, 0.000318520000f, 0.000357266700f, 0.000396000000f, 0.000433714700f,
    0.000473024000f, 0.000517876000f, 0.000572218700f, 0.000640000000f, 0.000724560000f, 0.000825500000f,
    0.000941160000f, 0.001069880000f, 0.001210000000f, 0.001362091000f, 0.001530752000f, 0.001720368000f,
    0.001935323000f, 0.002180000000f, 0.002454800000f, 0.002764000000f, 0.003117800000f, 0.003526400000f,
    0.004000000000f, 0.004546240000f, 0.005159320000f, 0.005829280000f, 0.006546160000f, 0.007300000000f,
    0.008086507000f, 0.008908720000f, 0.009767680000f, 0.010664430000f, 0.011600000000f, 0.012573170000f,
    0.013582720000f, 0.014629680000f, 0.015715090000f, 0.016840000000f, 0.018007360000f, 0.019214480000f,
    0.020453920000f, 0.021718240000f, 0.023000000000f, 0.024294610000f, 0.025610240000f, 0.026958570000f,
    0.028351250000f, 0.029800000000f, 0.031310830000f, 0.032883680000f, 0.034521120000f, 0.036225710000f,
    0.038000000000f, 0.039846670000f, 0.041768000000f, 0.043766000000f, 0.045842670000f, 0.048000000000f,
    0.050243680000f, 0.052573040000f, 0.054980560000f, 0.057458720000f, 0.060000000000f, 0.062601970000f,
    0.065277520000f, 0.068042080000f, 0.070911090000f, 0.073900000000f, 0.077016000000f, 0.080266400000f,
    0.083666800000f, 0.087232800000f, 0.090980000000f, 0.094917550000f, 0.099045840000f, 0.103367400000f,
    0.107884600000f, 0.112600000000f, 0.117532000000f, 0.122674400000f, 0.127992800000f, 0.133452800000f,
    0.139020000000f, 0.144676400000f, 0.150469300000f, 0.156461900000f, 0.162717700000f, 0.169300000000f,
    0.176243100000f, 0.183558100000f, 0.191273500000f, 0.199418000000f, 0.208020000000f, 0.217119900000f,
    0.226734500000f, 0.236857100000f, 0.247481200000f, 0.258600000000f, 0.270184900000f, 0.282293900000f,
    0.295050500000f, 0.308578000000f, 0.323000000000f, 0.338402100000f, 0.354685800000f, 0.371698600000f,
    0.389287500000f, 0.407300000000f, 0.425629900000f, 0.444309600000f, 0.463394400000f, 0.482939500000f,
    0.503000000000f, 0.523569300000f, 0.544512000000f, 0.565690000000f, 0.586965300000f, 0.608200000000f,
    0.629345600000f, 0.650306800000f, 0.670875200000f, 0.690842400000f, 0.710000000000f, 0.728185200000f,
    0.745463600000f, 0.761969400000f, 0.777836800000f, 0.793200000000f, 0.808110400000f, 0.822496200000f,
    0.836306800000f, 0.849491600000f, 0.862000000000f, 0.873810800000f, 0.884962400000f, 0.895493600000f,
    0.905443200000f, 0.914850100000f, 0.923734800000f, 0.932092400000f, 0.939922600000f, 0.947225200000f,
    0.954000000000f, 0.960256100000f, 0.966007400000f, 0.971260600000f, 0.976022500000f, 0.980300000000f,
    0.984092400000f, 0.987418200000f, 0.990312800000f, 0.992811600000f, 0.994950100000f, 0.996710800000f,
    0.998098300000f, 0.999112000000f, 0.999748200000f, 1.000000000000f, 0.999856700000f, 0.999304600000f,
    0.998325500000f, 0.996898700000f, 0.995000000000f, 0.992600500000f, 0.989742600000f, 0.986444400000f,
    0.982724100000f, 0.978600000000f, 0.974083700000f, 0.969171200000f, 0.963856800000f, 0.958134900000f,
    0.952000000000f, 0.945450400000f, 0.938499200000f, 0.931162800000f, 0.923457600000f, 0.915400000000f,
    0.907006400000f, 0.898277200000f, 0.889204800000f, 0.879781600000f, 0.870000000000f, 0.859861300000f,
    0.849392000000f, 0.838622000000f, 0.827581300000f, 0.816300000000f, 0.804794700000f, 0.793082000000f,
    0.781192000000f, 0.769154700000f, 0.757000000000f, 0.744754100000f, 0.732422400000f, 0.720003600000f,
    0.707496500000f, 0.694900000000f, 0.682219200000f, 0.669471600000f, 0.656674400000f, 0.643844800000f,
    0.631000000000f, 0.618155500000f, 0.605314400000f, 0.592475600000f, 0.579637900000f, 0.566800000000f,
    0.553961100000f, 0.541137200000f, 0.528352800000f, 0.515632300000f, 0.503000000000f, 0.490468800000f,
    0.478030400000f, 0.465677600000f, 0.453403200000f, 0.441200000000f, 0.429080000000f, 0.417036000000f,
    0.405032000000f, 0.393032000000f, 0.381000000000f, 0.368918400000f, 0.356827200000f, 0.344776800000f,
    0.332817600000f, 0.321000000000f, 0.309338100000f, 0.297850400000f, 0.286593600000f, 0.275624500000f,
    0.265000000000f, 0.254763200000f, 0.244889600000f, 0.235334400000f, 0.226052800000f, 0.217000000000f,
    0.208161600000f, 0.199548800000f, 0.191155200000f, 0.182974400000f, 0.175000000000f, 0.167223500000f,
    0.159646400000f, 0.152277600000f, 0.145125900000f, 0.138200000000f, 0.131500300000f, 0.125024800000f,
    0.118779200000f, 0.112769100000f, 0.107000000000f, 0.101476200000f, 0.096188640000f, 0.091122960000f,
    0.086264850000f, 0.081600000000f, 0.077120640000f, 0.072825520000f, 0.068710080000f, 0.064769760000f,
    0.061000000000f, 0.057396210000f, 0.053955040000f, 0.050673760000f, 0.047549650000f, 0.044580000000f,
    0.041758720000f, 0.039084960000f, 0.036563840000f, 0.034200480000f, 0.032000000000f, 0.029962610000f,
    0.028076640000f, 0.026329360000f, 0.024708050000f, 0.023200000000f, 0.021800770000f, 0.020501120000f,
    0.019281080000f, 0.018120690000f, 0.017000000000f, 0.015903790000f, 0.014837180000f, 0.013810680000f,
    0.012834780000f, 0.011920000000f, 0.011068310000f, 0.010273390000f, 0.009533311000f, 0.008846157000f,
    0.008210000000f, 0.007623781000f, 0.007085424000f, 0.006591476000f, 0.006138485000f, 0.005723000000f,
    0.005343059000f, 0.004995796000f, 0.004676404000f, 0.004380075000f, 0.004102000000f, 0.003838453000f,
    0.003589099000f, 0.003354219000f, 0.003134093000f, 0.002929000000f, 0.002738139000f, 0.002559876000f,
    0.002393244000f, 0.002237275000f, 0.002091000000f, 0.001953587000f, 0.001824580000f, 0.001703580000f,
    0.001590187000f, 0.001484000000f, 0.001384496000f, 0.001291268000f, 0.001204092000f, 0.001122744000f,
    0.001047000000f, 0.000976589600f, 0.000911108800f, 0.000850133200f, 0.000793238400f, 0.000740000000f,
    0.000690082700f, 0.000643310000f, 0.000599496000f, 0.000558454700f, 0.000520000000f, 0.000483913600f,
    0.000450052800f, 0.000418345200f, 0.000388718400f, 0.000361100000f, 0.000335383500f, 0.000311440400f,
    0.000289165600f, 0.000268453900f, 0.000249200000f, 0.000231301900f, 0.000214685600f, 0.000199288400f,
    0.000185047500f, 0.000171900000f, 0.000159778100f, 0.000148604400f, 0.000138301600f, 0.000128792500f,
    0.000120000000f, 0.000111859500f, 0.000104322400f, 0.000097335600f, 0.000090845870f, 0.000084800000f,
    0.000079146670f, 0.000073858000f, 0.000068916000f, 0.000064302670f, 0.000060000000f, 0.000055981870f,
    0.000052225600f, 0.000048718400f, 0.000045447470f, 0.000042400000f, 0.000039561040f, 0.000036915120f,
    0.000034448680f, 0.000032148160f, 0.000030000000f, 0.000027991250f, 0.000026113560f, 0.000024360240f,
    0.000022724610f, 0.000021200000f, 0.000019778550f, 0.000018452850f, 0.000017216870f, 0.000016064590f,
    0.000014990000f, 0.000013987280f, 0.000013051550f, 0.000012178180f, 0.000011362540f, 0.000010600000f,
    0.000009885877f, 0.000009217304f, 0.000008592362f, 0.000008009133f, 0.000007465700f, 0.000006959567f,
    0.000006487995f, 0.000006048699f, 0.000005639396f, 0.000005257800f, 0.000004901771f, 0.000004569720f,
    0.000004260194f, 0.000003971739f, 0.000003702900f, 0.000003452163f, 0.000003218302f, 0.000003000300f,
    0.000002797139f, 0.000002607800f, 0.000002431220f, 0.000002266531f, 0.000002113013f, 0.000001969943f,
    0.000001836600f, 0.000001712230f, 0.000001596228f, 0.000001488090f, 0.000001387314f, 0.000001293400f,
    0.000001205820f, 0.000001124143f, 0.000001048009f, 0.000000977058f, 0.000000910930f, 0.000000849251f,
    0.000000791721f, 0.000000738090f, 0.000000688110f, 0.000000641530f, 0.000000598090f, 0.000000557575f,
    0.000000519808f, 0.000000484612f, 0.000000451810f};
static float s_CIE_1931_2deg_Z[] = {
    0.000606100000f, 0.000680879200f, 0.000765145600f, 0.000860012400f, 0.000966592800f, 0.001086000000f,
    0.001220586000f, 0.001372729000f, 0.001543579000f, 0.001734286000f, 0.001946000000f, 0.002177777000f,
    0.002435809000f, 0.002731953000f, 0.003078064000f, 0.003486000000f, 0.003975227000f, 0.004540880000f,
    0.005158320000f, 0.005802907000f, 0.006450001000f, 0.007083216000f, 0.007745488000f, 0.008501152000f,
    0.009414544000f, 0.010549990000f, 0.011965800000f, 0.013655870000f, 0.015588050000f, 0.017730150000f,
    0.020050010000f, 0.022511360000f, 0.025202880000f, 0.028279720000f, 0.031897040000f, 0.036210000000f,
    0.041437710000f, 0.047503720000f, 0.054119880000f, 0.060998030000f, 0.067850010000f, 0.074486320000f,
    0.081361560000f, 0.089153640000f, 0.098540480000f, 0.110200000000f, 0.124613300000f, 0.141701700000f,
    0.161303500000f, 0.183256800000f, 0.207400000000f, 0.233692100000f, 0.262611400000f, 0.294774600000f,
    0.330798500000f, 0.371300000000f, 0.416209100000f, 0.465464200000f, 0.519694800000f, 0.579530300000f,
    0.645600000000f, 0.718483800000f, 0.796713300000f, 0.877845900000f, 0.959439000000f, 1.039050100000f,
    1.115367300000f, 1.188497100000f, 1.258123300000f, 1.323929600000f, 1.385600000000f, 1.442635200000f,
    1.494803500000f, 1.542190300000f, 1.584880700000f, 1.622960000000f, 1.656404800000f, 1.685295900000f,
    1.709874500000f, 1.730382100000f, 1.747060000000f, 1.760044600000f, 1.769623300000f, 1.776263700000f,
    1.780433400000f, 1.782600000000f, 1.782968200000f, 1.781699800000f, 1.779198200000f, 1.775867100000f,
    1.772110000000f, 1.768258900000f, 1.764039000000f, 1.758943800000f, 1.752466300000f, 1.744100000000f,
    1.733559500000f, 1.720858100000f, 1.705936900000f, 1.688737200000f, 1.669200000000f, 1.647528700000f,
    1.623412700000f, 1.596022300000f, 1.564528000000f, 1.528100000000f, 1.486111400000f, 1.439521500000f,
    1.389879900000f, 1.338736200000f, 1.287640000000f, 1.237422300000f, 1.187824300000f, 1.138761100000f,
    1.090148000000f, 1.041900000000f, 0.994197600000f, 0.947347300000f, 0.901453100000f, 0.856619300000f,
    0.812950100000f, 0.770517300000f, 0.729444800000f, 0.689913600000f, 0.652104900000f, 0.616200000000f,
    0.582328600000f, 0.550416200000f, 0.520337600000f, 0.491967300000f, 0.465180000000f, 0.439924600000f,
    0.416183600000f, 0.393882200000f, 0.372945900000f, 0.353300000000f, 0.334857800000f, 0.317552100000f,
    0.301337500000f, 0.286168600000f, 0.272000000000f, 0.258817100000f, 0.246483800000f, 0.234771800000f,
    0.223453300000f, 0.212300000000f, 0.201169200000f, 0.190119600000f, 0.179225400000f, 0.168560800000f,
    0.158200000000f, 0.148138300000f, 0.138375800000f, 0.128994200000f, 0.120075100000f, 0.111700000000f,
    0.103904800000f, 0.096667480000f, 0.089982720000f, 0.083845310000f, 0.078249990000f, 0.073208990000f,
    0.068678160000f, 0.064567840000f, 0.060788350000f, 0.057250010000f, 0.053904350000f, 0.050746640000f,
    0.047752760000f, 0.044898590000f, 0.042160000000f, 0.039507280000f, 0.036935640000f, 0.034458360000f,
    0.032088720000f, 0.029840000000f, 0.027711810000f, 0.025694440000f, 0.023787160000f, 0.021989250000f,
    0.020300000000f, 0.018718050000f, 0.017240360000f, 0.015863640000f, 0.014584610000f, 0.013400000000f,
    0.012307230000f, 0.011301880000f, 0.010377920000f, 0.009529306000f, 0.008749999000f, 0.008035200000f,
    0.007381600000f, 0.006785400000f, 0.006242800000f, 0.005749999000f, 0.005303600000f, 0.004899800000f,
    0.004534200000f, 0.004202400000f, 0.003900000000f, 0.003623200000f, 0.003370600000f, 0.003141400000f,
    0.002934800000f, 0.002749999000f, 0.002585200000f, 0.002438600000f, 0.002309400000f, 0.002196800000f,
    0.002100000000f, 0.002017733000f, 0.001948200000f, 0.001889800000f, 0.001840933000f, 0.001800000000f,
    0.001766267000f, 0.001737800000f, 0.001711200000f, 0.001683067000f, 0.001650001000f, 0.001610133000f,
    0.001564400000f, 0.001513600000f, 0.001458533000f, 0.001400000000f, 0.001336667000f, 0.001270000000f,
    0.001205000000f, 0.001146667000f, 0.001100000000f, 0.001068800000f, 0.001049400000f, 0.001035600000f,
    0.001021200000f, 0.001000000000f, 0.000968640000f, 0.000929920000f, 0.000886880000f, 0.000842560000f,
    0.000800000000f, 0.000760960000f, 0.000723680000f, 0.000685920000f, 0.000645440000f, 0.000600000000f,
    0.000547866700f, 0.000491600000f, 0.000435400000f, 0.000383466700f, 0.000340000000f, 0.000307253300f,
    0.000283160000f, 0.000265440000f, 0.000251813300f, 0.000240000000f, 0.000229546700f, 0.000220640000f,
    0.000211960000f, 0.000202186700f, 0.000190000000f, 0.000174213300f, 0.000155640000f, 0.000135960000f,
    0.000116853300f, 0.000100000000f, 0.000086133330f, 0.000074600000f, 0.000065000000f, 0.000056933330f,
    0.000049999990f, 0.000044160000f, 0.000039480000f, 0.000035720000f, 0.000032640000f, 0.000030000000f,
    0.000027653330f, 0.000025560000f, 0.000023640000f, 0.000021813330f, 0.000020000000f, 0.000018133330f,
    0.000016200000f, 0.000014200000f, 0.000012133330f, 0.000010000000f, 0.000007733333f, 0.000005400000f,
    0.000003200000f, 0.000001333333f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f};

// src: https://github.com/hughsie/colord/tree/main/data/illuminant
static float s_Illuminance_D65_min = 300.0f;
static float s_Illuminance_D65_max = 830.0f;
#define s_Illuminance_D65_samplesCount 531
static float s_Illuminance_D65[] = {
    0.034100f,   0.360140f,   0.686180f,   1.012220f,   1.338260f,   1.664300f,   1.990340f,   2.316380f,   2.642420f,
    2.968460f,   3.294500f,   4.988650f,   6.682800f,   8.376950f,   10.071100f,  11.765200f,  13.459400f,  15.153500f,
    16.847700f,  18.541800f,  20.236000f,  21.917700f,  23.599500f,  25.281200f,  26.963000f,  28.644700f,  30.326500f,
    32.008200f,  33.690000f,  35.371700f,  37.053500f,  37.343000f,  37.632600f,  37.922100f,  38.211600f,  38.501100f,
    38.790700f,  39.080200f,  39.369700f,  39.659300f,  39.948800f,  40.445100f,  40.941400f,  41.437700f,  41.934000f,
    42.430200f,  42.926500f,  43.422800f,  43.919100f,  44.415400f,  44.911700f,  45.084400f,  45.257000f,  45.429700f,
    45.602300f,  45.775000f,  45.947700f,  46.120300f,  46.293000f,  46.465600f,  46.638300f,  47.183400f,  47.728500f,
    48.273500f,  48.818600f,  49.363700f,  49.908800f,  50.453900f,  50.998900f,  51.544000f,  52.089100f,  51.877700f,
    51.666400f,  51.455000f,  51.243700f,  51.032300f,  50.820900f,  50.609600f,  50.398200f,  50.186900f,  49.975500f,
    50.442800f,  50.910000f,  51.377300f,  51.844600f,  52.311800f,  52.779100f,  53.246400f,  53.713700f,  54.180900f,
    54.648200f,  57.458900f,  60.269500f,  63.080200f,  65.890900f,  68.701500f,  71.512200f,  74.322900f,  77.133600f,
    79.944200f,  82.754900f,  83.628000f,  84.501100f,  85.374200f,  86.247300f,  87.120400f,  87.993600f,  88.866700f,
    89.739800f,  90.612900f,  91.486000f,  91.680600f,  91.875200f,  92.069700f,  92.264300f,  92.458900f,  92.653500f,
    92.848100f,  93.042600f,  93.237200f,  93.431800f,  92.756800f,  92.081900f,  91.406900f,  90.732000f,  90.057000f,
    89.382100f,  88.707100f,  88.032200f,  87.357200f,  86.682300f,  88.500600f,  90.318800f,  92.137100f,  93.955400f,
    95.773600f,  97.591900f,  99.410200f,  101.228000f, 103.047000f, 104.865000f, 106.079000f, 107.294000f, 108.508000f,
    109.722000f, 110.936000f, 112.151000f, 113.365000f, 114.579000f, 115.794000f, 117.008000f, 117.088000f, 117.169000f,
    117.249000f, 117.330000f, 117.410000f, 117.490000f, 117.571000f, 117.651000f, 117.732000f, 117.812000f, 117.517000f,
    117.222000f, 116.927000f, 116.632000f, 116.336000f, 116.041000f, 115.746000f, 115.451000f, 115.156000f, 114.861000f,
    114.967000f, 115.073000f, 115.180000f, 115.286000f, 115.392000f, 115.498000f, 115.604000f, 115.711000f, 115.817000f,
    115.923000f, 115.212000f, 114.501000f, 113.789000f, 113.078000f, 112.367000f, 111.656000f, 110.945000f, 110.233000f,
    109.522000f, 108.811000f, 108.865000f, 108.920000f, 108.974000f, 109.028000f, 109.082000f, 109.137000f, 109.191000f,
    109.245000f, 109.300000f, 109.354000f, 109.199000f, 109.044000f, 108.888000f, 108.733000f, 108.578000f, 108.423000f,
    108.268000f, 108.112000f, 107.957000f, 107.802000f, 107.501000f, 107.200000f, 106.898000f, 106.597000f, 106.296000f,
    105.995000f, 105.694000f, 105.392000f, 105.091000f, 104.790000f, 105.080000f, 105.370000f, 105.660000f, 105.950000f,
    106.239000f, 106.529000f, 106.819000f, 107.109000f, 107.399000f, 107.689000f, 107.361000f, 107.032000f, 106.704000f,
    106.375000f, 106.047000f, 105.719000f, 105.390000f, 105.062000f, 104.733000f, 104.405000f, 104.369000f, 104.333000f,
    104.297000f, 104.261000f, 104.225000f, 104.190000f, 104.154000f, 104.118000f, 104.082000f, 104.046000f, 103.641000f,
    103.237000f, 102.832000f, 102.428000f, 102.023000f, 101.618000f, 101.214000f, 100.809000f, 100.405000f, 100.000000f,
    99.633400f,  99.266800f,  98.900300f,  98.533700f,  98.167100f,  97.800500f,  97.433900f,  97.067400f,  96.700800f,
    96.334200f,  96.279600f,  96.225000f,  96.170300f,  96.115700f,  96.061100f,  96.006500f,  95.951900f,  95.897200f,
    95.842600f,  95.788000f,  95.077800f,  94.367500f,  93.657300f,  92.947000f,  92.236800f,  91.526600f,  90.816300f,
    90.106100f,  89.395800f,  88.685600f,  88.817700f,  88.949700f,  89.081800f,  89.213800f,  89.345900f,  89.478000f,
    89.610000f,  89.742100f,  89.874100f,  90.006200f,  89.965500f,  89.924800f,  89.884100f,  89.843400f,  89.802600f,
    89.761900f,  89.721200f,  89.680500f,  89.639800f,  89.599100f,  89.409100f,  89.219000f,  89.029000f,  88.838900f,
    88.648900f,  88.458900f,  88.268800f,  88.078800f,  87.888700f,  87.698700f,  87.257700f,  86.816700f,  86.375700f,
    85.934700f,  85.493600f,  85.052600f,  84.611600f,  84.170600f,  83.729600f,  83.288600f,  83.329700f,  83.370700f,
    83.411800f,  83.452800f,  83.493900f,  83.535000f,  83.576000f,  83.617100f,  83.658100f,  83.699200f,  83.332000f,
    82.964700f,  82.597500f,  82.230200f,  81.863000f,  81.495800f,  81.128500f,  80.761300f,  80.394000f,  80.026800f,
    80.045600f,  80.064400f,  80.083100f,  80.101900f,  80.120700f,  80.139500f,  80.158300f,  80.177000f,  80.195800f,
    80.214600f,  80.420900f,  80.627200f,  80.833600f,  81.039900f,  81.246200f,  81.452500f,  81.658800f,  81.865200f,
    82.071500f,  82.277800f,  81.878400f,  81.479100f,  81.079700f,  80.680400f,  80.281000f,  79.881600f,  79.482300f,
    79.082900f,  78.683600f,  78.284200f,  77.427900f,  76.571600f,  75.715300f,  74.859000f,  74.002700f,  73.146500f,
    72.290200f,  71.433900f,  70.577600f,  69.721300f,  69.910100f,  70.098900f,  70.287600f,  70.476400f,  70.665200f,
    70.854000f,  71.042800f,  71.231500f,  71.420300f,  71.609100f,  71.883100f,  72.157100f,  72.431100f,  72.705100f,
    72.979000f,  73.253000f,  73.527000f,  73.801000f,  74.075000f,  74.349000f,  73.074500f,  71.800000f,  70.525500f,
    69.251000f,  67.976500f,  66.702000f,  65.427500f,  64.153000f,  62.878500f,  61.604000f,  62.432200f,  63.260300f,
    64.088500f,  64.916600f,  65.744800f,  66.573000f,  67.401100f,  68.229300f,  69.057400f,  69.885600f,  70.405700f,
    70.925900f,  71.446000f,  71.966200f,  72.486300f,  73.006400f,  73.526600f,  74.046700f,  74.566900f,  75.087000f,
    73.937600f,  72.788100f,  71.638700f,  70.489300f,  69.339800f,  68.190400f,  67.041000f,  65.891600f,  64.742100f,
    63.592700f,  61.875200f,  60.157800f,  58.440300f,  56.722900f,  55.005400f,  53.288000f,  51.570500f,  49.853100f,
    48.135600f,  46.418200f,  48.456900f,  50.495600f,  52.534400f,  54.573100f,  56.611800f,  58.650500f,  60.689200f,
    62.728000f,  64.766700f,  66.805400f,  66.463100f,  66.120900f,  65.778600f,  65.436400f,  65.094100f,  64.751800f,
    64.409600f,  64.067300f,  63.725100f,  63.382800f,  63.474900f,  63.567000f,  63.659200f,  63.751300f,  63.843400f,
    63.935500f,  64.027600f,  64.119800f,  64.211900f,  64.304000f,  63.818800f,  63.333600f,  62.848400f,  62.363200f,
    61.877900f,  61.392700f,  60.907500f,  60.422300f,  59.937100f,  59.451900f,  58.702600f,  57.953300f,  57.204000f,
    56.454700f,  55.705400f,  54.956200f,  54.206900f,  53.457600f,  52.708300f,  51.959000f,  52.507200f,  53.055300f,
    53.603500f,  54.151600f,  54.699800f,  55.248000f,  55.796100f,  56.344300f,  56.892400f,  57.440600f,  57.727800f,
    58.015000f,  58.302200f,  58.589400f,  58.876500f,  59.163700f,  59.450900f,  59.738100f,  60.025300f,  60.312500f};

static float s_min_kelvin_temp          = 1000.0f;
static float s_max_kelvin_temp          = 12000.0f;
static int   s_kelvin_temp_count        = 111;
static float s_kelvin_sRGB_Colors_Red[] = {
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 252, 249, 247, 245, 243, 240, 239, 237, 235, 233, 231, 230,
    228, 227, 225, 224, 222, 221, 220, 218, 217, 216, 215, 214, 212, 211, 210, 209, 208, 207, 207, 206, 205, 207, 207,
    206, 205, 204, 204, 203, 202, 202, 201, 200, 200, 199, 198, 198, 197, 197, 197, 196, 195, 195};
static float s_kelvin_sRGB_Colors_Green[] = {
    56,  71,  83,  93,  101, 109, 115, 121, 126, 131, 138, 142, 147, 152, 157, 161, 165, 169, 173, 177, 180, 184, 187,
    190, 193, 196, 199, 201, 204, 206, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 228, 230, 232, 233, 235, 236,
    238, 239, 240, 242, 243, 244, 245, 246, 248, 249, 249, 247, 246, 245, 243, 242, 241, 240, 239, 238, 237, 236, 235,
    234, 233, 232, 231, 230, 230, 229, 229, 227, 227, 226, 225, 225, 224, 223, 223, 222, 221, 221, 220, 220, 218, 218,
    217, 217, 216, 216, 215, 215, 214, 214, 213, 213, 212, 212, 212, 211, 211, 210, 210, 210, 209};
static float s_kelvin_sRGB_Colors_Blue[] = {
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   18,  33,  44,  54,  63,  72,  79,  87,  94,  101, 107, 114, 120,
    126, 132, 137, 143, 148, 153, 159, 163, 168, 173, 177, 182, 186, 190, 194, 198, 202, 206, 210, 213, 217, 220, 224,
    227, 230, 233, 236, 239, 242, 245, 247, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};

static float s_ColorSpace_RGB2XYZ_sRGB[] = {0.4124564f, 0.3575761f, 0.1804375f, 0.2126729f, 0.7151522f,
                                            0.0721750f, 0.0193339f, 0.1191920f, 0.9503041f};
//////////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////////
void ScaleData(ImGuiDataType data_type, void *p_data, double value)
{
    switch (data_type)
    {
    case ImGuiDataType_S8: *reinterpret_cast<ImS8 *>(p_data) *= static_cast<ImS8>(value); break;
    case ImGuiDataType_U8: *reinterpret_cast<ImU8 *>(p_data) *= static_cast<ImU8>(value); break;
    case ImGuiDataType_S16: *reinterpret_cast<ImS16 *>(p_data) *= static_cast<ImS16>(value); break;
    case ImGuiDataType_U16: *reinterpret_cast<ImU16 *>(p_data) *= static_cast<ImU16>(value); break;
    case ImGuiDataType_S32: *reinterpret_cast<ImS32 *>(p_data) *= static_cast<ImS32>(value); break;
    case ImGuiDataType_U32: *reinterpret_cast<ImU32 *>(p_data) *= static_cast<ImU32>(value); break;
    case ImGuiDataType_S64: *reinterpret_cast<ImS64 *>(p_data) *= static_cast<ImS64>(value); break;
    case ImGuiDataType_U64: *reinterpret_cast<ImU64 *>(p_data) *= static_cast<ImU64>(value); break;
    case ImGuiDataType_Float: *reinterpret_cast<float *>(p_data) *= static_cast<float>(value); break;
    case ImGuiDataType_Double: *reinterpret_cast<double *>(p_data) *= value; break;
    }
}
void ScaleData(ImGuiDataType data_type, void *p_data, ImU64 value)
{
    switch (data_type)
    {
    case ImGuiDataType_S8: *reinterpret_cast<ImS8 *>(p_data) *= static_cast<ImS8>(value); break;
    case ImGuiDataType_U8: *reinterpret_cast<ImU8 *>(p_data) *= static_cast<ImU8>(value); break;
    case ImGuiDataType_S16: *reinterpret_cast<ImS16 *>(p_data) *= static_cast<ImS16>(value); break;
    case ImGuiDataType_U16: *reinterpret_cast<ImU16 *>(p_data) *= static_cast<ImU16>(value); break;
    case ImGuiDataType_S32: *reinterpret_cast<ImS32 *>(p_data) *= static_cast<ImS32>(value); break;
    case ImGuiDataType_U32: *reinterpret_cast<ImU32 *>(p_data) *= static_cast<ImU32>(value); break;
    case ImGuiDataType_S64: *reinterpret_cast<ImS64 *>(p_data) *= static_cast<ImS64>(value); break;
    case ImGuiDataType_U64: *reinterpret_cast<ImU64 *>(p_data) *= static_cast<ImU64>(value); break;
    case ImGuiDataType_Float: *reinterpret_cast<float *>(p_data) *= static_cast<float>(value); break;
    case ImGuiDataType_Double: *reinterpret_cast<double *>(p_data) *= value; break;
    }
}

bool IsNegativeScalar(ImGuiDataType data_type, ImU64 *src)
{
    switch (data_type)
    {
    case ImGuiDataType_S8:
    {
        ImS8 value = *reinterpret_cast<ImS8 *>(src);
        return value < 0;
    }
    break;
    case ImGuiDataType_S16:
    {
        ImS16 value = *reinterpret_cast<ImS16 *>(src);
        return value < 0;
    }
    break;
    case ImGuiDataType_S32:
    {
        ImS32 value = *reinterpret_cast<ImS32 *>(src);
        return value < 0l;
    }
    break;
    case ImGuiDataType_S64:
    {
        ImS64 value = *reinterpret_cast<ImS64 *>(src);
        return value < 0ll;
    }
    break;
    case ImGuiDataType_U8:
    case ImGuiDataType_U16:
    case ImGuiDataType_U32:
    case ImGuiDataType_U64:
    {
        return false;
    }
    break;
    case ImGuiDataType_Float:
    {
        float value = *reinterpret_cast<float *>(src);
        return value < 0.0f;
    }
    break;
    case ImGuiDataType_Double:
    {
        double value = *reinterpret_cast<double *>(src);
        return value < 0.0f;
    }
    break;
    }

    return false;
}

bool IsPositiveScalar(ImGuiDataType data_type, ImU64 *src) { return !IsNegativeScalar(data_type, src); }

void EqualScalar(ImGuiDataType data_type, ImU64 *p_target, ImU64 *p_source)
{
    switch (data_type)
    {
    case ImGuiDataType_S8: *reinterpret_cast<ImS8 *>(p_target) = *reinterpret_cast<ImS8 *>(p_source); break;
    case ImGuiDataType_U8: *reinterpret_cast<ImU8 *>(p_target) = *reinterpret_cast<ImU8 *>(p_source); break;
    case ImGuiDataType_S16: *reinterpret_cast<ImS16 *>(p_target) = *reinterpret_cast<ImS16 *>(p_source); break;
    case ImGuiDataType_U16: *reinterpret_cast<ImU16 *>(p_target) = *reinterpret_cast<ImU16 *>(p_source); break;
    case ImGuiDataType_S32: *reinterpret_cast<ImS32 *>(p_target) = *reinterpret_cast<ImS32 *>(p_source); break;
    case ImGuiDataType_U32: *reinterpret_cast<ImU64 *>(p_target) = *reinterpret_cast<ImU32 *>(p_source); break;
    case ImGuiDataType_S64: *reinterpret_cast<ImS64 *>(p_target) = *reinterpret_cast<ImS64 *>(p_source); break;
    case ImGuiDataType_U64: *reinterpret_cast<ImU64 *>(p_target) = *reinterpret_cast<ImU64 *>(p_source); break;
    case ImGuiDataType_Float: *reinterpret_cast<float *>(p_target) = *reinterpret_cast<float *>(p_source); break;
    case ImGuiDataType_Double: *reinterpret_cast<double *>(p_target) = *reinterpret_cast<double *>(p_source); break;
    }
}

void SetScalarIndirect(ImGuiDataType data_type, void *p_target, int idx, ImU64 *p_source)
{
    switch (data_type)
    {
    case ImGuiDataType_S8: reinterpret_cast<ImS8 *>(p_target)[idx] = *reinterpret_cast<ImS8 *>(p_source); break;
    case ImGuiDataType_U8: reinterpret_cast<ImU8 *>(p_target)[idx] = *reinterpret_cast<ImU8 *>(p_source); break;
    case ImGuiDataType_S16: reinterpret_cast<ImS16 *>(p_target)[idx] = *reinterpret_cast<ImS16 *>(p_source); break;
    case ImGuiDataType_U16: reinterpret_cast<ImU16 *>(p_target)[idx] = *reinterpret_cast<ImU16 *>(p_source); break;
    case ImGuiDataType_S32: reinterpret_cast<ImS32 *>(p_target)[idx] = *reinterpret_cast<ImS32 *>(p_source); break;
    case ImGuiDataType_U32: reinterpret_cast<ImU64 *>(p_target)[idx] = *reinterpret_cast<ImU32 *>(p_source); break;
    case ImGuiDataType_S64: reinterpret_cast<ImS64 *>(p_target)[idx] = *reinterpret_cast<ImS64 *>(p_source); break;
    case ImGuiDataType_U64: reinterpret_cast<ImU64 *>(p_target)[idx] = *reinterpret_cast<ImU64 *>(p_source); break;
    case ImGuiDataType_Float: reinterpret_cast<float *>(p_target)[idx] = *reinterpret_cast<float *>(p_source); break;
    case ImGuiDataType_Double: reinterpret_cast<double *>(p_target)[idx] = *reinterpret_cast<double *>(p_source); break;
    }
}

float ScalarToFloat(ImGuiDataType data_type, ImU64 *p_source)
{
    switch (data_type)
    {
    case ImGuiDataType_S8: return static_cast<float>(*reinterpret_cast<ImS8 *>(p_source));
    case ImGuiDataType_U8: return static_cast<float>(*reinterpret_cast<ImU8 *>(p_source));
    case ImGuiDataType_S16: return static_cast<float>(*reinterpret_cast<ImS16 *>(p_source));
    case ImGuiDataType_U16: return static_cast<float>(*reinterpret_cast<ImU16 *>(p_source));
    case ImGuiDataType_S32: return static_cast<float>(*reinterpret_cast<ImS32 *>(p_source));
    case ImGuiDataType_U32: return static_cast<float>(*reinterpret_cast<ImU32 *>(p_source));
    case ImGuiDataType_S64: return static_cast<float>(*reinterpret_cast<ImS64 *>(p_source));
    case ImGuiDataType_U64: return static_cast<float>(*reinterpret_cast<ImU64 *>(p_source));
    case ImGuiDataType_Float: return static_cast<float>(*reinterpret_cast<float *>(p_source));
    case ImGuiDataType_Double: return static_cast<float>(*reinterpret_cast<double *>(p_source));
    }

    return 0.0f;
}

float ScalarIndirectToFloat(ImGuiDataType data_type, void *p_source, int idx)
{
    switch (data_type)
    {
    case ImGuiDataType_S8: return static_cast<float>(reinterpret_cast<ImS8 *>(p_source)[idx]);
    case ImGuiDataType_U8: return static_cast<float>(reinterpret_cast<ImU8 *>(p_source)[idx]);
    case ImGuiDataType_S16: return static_cast<float>(reinterpret_cast<ImS16 *>(p_source)[idx]);
    case ImGuiDataType_U16: return static_cast<float>(reinterpret_cast<ImU16 *>(p_source)[idx]);
    case ImGuiDataType_S32: return static_cast<float>(reinterpret_cast<ImS32 *>(p_source)[idx]);
    case ImGuiDataType_U32: return static_cast<float>(reinterpret_cast<ImU32 *>(p_source)[idx]);
    case ImGuiDataType_S64: return static_cast<float>(reinterpret_cast<ImS64 *>(p_source)[idx]);
    case ImGuiDataType_U64: return static_cast<float>(reinterpret_cast<ImU64 *>(p_source)[idx]);
    case ImGuiDataType_Float: return static_cast<float>(reinterpret_cast<float *>(p_source)[idx]);
    case ImGuiDataType_Double: return static_cast<float>(reinterpret_cast<double *>(p_source)[idx]);
    }

    return 0.0f;
}

ImU64 ScalarIndirectToScalar(ImGuiDataType data_type, void *p_source, int idx)
{
    switch (data_type)
    {
    case ImGuiDataType_S8: return static_cast<ImU64>(reinterpret_cast<ImS8 *>(p_source)[idx]);
    case ImGuiDataType_U8: return static_cast<ImU64>(reinterpret_cast<ImU8 *>(p_source)[idx]);
    case ImGuiDataType_S16: return static_cast<ImU64>(reinterpret_cast<ImS16 *>(p_source)[idx]);
    case ImGuiDataType_U16: return static_cast<ImU64>(reinterpret_cast<ImU16 *>(p_source)[idx]);
    case ImGuiDataType_S32: return static_cast<ImU64>(reinterpret_cast<ImS32 *>(p_source)[idx]);
    case ImGuiDataType_U32: return static_cast<ImU64>(reinterpret_cast<ImU32 *>(p_source)[idx]);
    case ImGuiDataType_S64: return static_cast<ImU64>(reinterpret_cast<ImS64 *>(p_source)[idx]);
    case ImGuiDataType_U64: return static_cast<ImU64>(reinterpret_cast<ImU64 *>(p_source)[idx]);
    case ImGuiDataType_Float: return static_cast<ImU64>(reinterpret_cast<float *>(p_source)[idx]);
    case ImGuiDataType_Double: return static_cast<ImU64>(reinterpret_cast<double *>(p_source)[idx]);
    }

    return ImU64(-1);
}

ImU64 FloatToScalar(ImGuiDataType data_type, float f_value)
{
    switch (data_type)
    {
    case ImGuiDataType_S8:
    {
        ImS8 value = static_cast<ImS8>(f_value);
        return static_cast<ImU64>(value);
    }
    case ImGuiDataType_U8:
    {
        ImU8 value = static_cast<ImU8>(f_value);
        return static_cast<ImU64>(value);
    }
    case ImGuiDataType_S16:
    {
        ImS16 value = static_cast<ImS16>(f_value);
        return static_cast<ImU64>(value);
    }
    case ImGuiDataType_U16:
    {
        ImU16 value = static_cast<ImU16>(f_value);
        return static_cast<ImU64>(value);
    }
    case ImGuiDataType_S32:
    {
        ImS32 value = static_cast<ImS32>(f_value);
        return static_cast<ImU64>(value);
    }
    case ImGuiDataType_U32:
    {
        ImU32 value = static_cast<ImU32>(f_value);
        return static_cast<ImU64>(value);
    }
    case ImGuiDataType_S64:
    {
        ImS64 value = static_cast<ImS64>(f_value);
        return static_cast<ImU64>(value);
    }
    case ImGuiDataType_U64:
    {
        ImU64 value = static_cast<ImU64>(f_value);
        return static_cast<ImU64>(value);
    }
    case ImGuiDataType_Float:
    {
        float value = f_value;
        return *reinterpret_cast<ImU64 *>(&value);
    }
    case ImGuiDataType_Double:
    {
        double value = static_cast<double>(f_value);
        return *reinterpret_cast<ImU64 *>(&value);
    }
    }

    return ImU64();
}

ImU64 AddScalar(ImGuiDataType data_type, void *p_a, void *p_b)
{
    ImU64 result;
    switch (data_type)
    {
    case ImGuiDataType_S8:
    {
        ImS8 value = *reinterpret_cast<ImS8 *>(p_a) + *static_cast<ImS8 *>(p_b);
        result     = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U8:
    {
        ImU8 value = *reinterpret_cast<ImU8 *>(p_a) + *static_cast<ImU8 *>(p_b);
        result     = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S16:
    {
        ImS16 value = *reinterpret_cast<ImS16 *>(p_a) + *static_cast<ImS16 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U16:
    {
        ImU16 value = *reinterpret_cast<ImU16 *>(p_a) + *static_cast<ImU16 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S32:
    {
        ImS32 value = *reinterpret_cast<ImS32 *>(p_a) + *static_cast<ImS32 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U32:
    {
        ImU32 value = *reinterpret_cast<ImU32 *>(p_a) + *static_cast<ImU32 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S64:
    {
        ImS64 value = *reinterpret_cast<ImS64 *>(p_a) + *static_cast<ImS64 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U64:
    {
        ImU64 value = *reinterpret_cast<ImU64 *>(p_a) + *static_cast<ImU64 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_Float:
    {
        float value = *reinterpret_cast<float *>(p_a) + *static_cast<float *>(p_b);
        result      = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    case ImGuiDataType_Double:
    {
        double value = *reinterpret_cast<double *>(p_a) + *static_cast<double *>(p_b);
        result       = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    }

    return result;
}

ImU64 SubScalar(ImGuiDataType data_type, void *p_a, void *p_b)
{
    ImU64 result = 0;
    switch (data_type)
    {
    case ImGuiDataType_S8:
    {
        ImS8 value = *reinterpret_cast<ImS8 *>(p_a) - *static_cast<ImS8 *>(p_b);
        result     = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U8:
    {
        ImU8 value = *reinterpret_cast<ImU8 *>(p_a) - *static_cast<ImU8 *>(p_b);
        result     = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S16:
    {
        ImS16 value = *reinterpret_cast<ImS16 *>(p_a) - *static_cast<ImS16 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U16:
    {
        ImU16 value = *reinterpret_cast<ImU16 *>(p_a) - *static_cast<ImU16 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S32:
    {
        ImS32 value = *reinterpret_cast<ImS32 *>(p_a) - *static_cast<ImS32 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U32:
    {
        ImU32 value = *reinterpret_cast<ImU32 *>(p_a) - *static_cast<ImU32 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S64:
    {
        ImS64 value = *reinterpret_cast<ImS64 *>(p_a) - *static_cast<ImS64 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U64:
    {
        ImU64 value = *reinterpret_cast<ImU64 *>(p_a) - *static_cast<ImU64 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_Float:
    {
        float value = *reinterpret_cast<float *>(p_a) - *static_cast<float *>(p_b);
        result      = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    case ImGuiDataType_Double:
    {
        double value = *reinterpret_cast<double *>(p_a) - *static_cast<double *>(p_b);
        result       = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    }

    return result;
}

ImU64 MulScalar(ImGuiDataType data_type, void *p_a, void *p_b)
{
    ImU64 result;
    switch (data_type)
    {
    case ImGuiDataType_S8:
    {
        ImS8 value = *reinterpret_cast<ImS8 *>(p_a) * *static_cast<ImS8 *>(p_b);
        result     = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U8:
    {
        ImU8 value = *reinterpret_cast<ImU8 *>(p_a) * *static_cast<ImU8 *>(p_b);
        result     = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S16:
    {
        ImS16 value = *reinterpret_cast<ImS16 *>(p_a) * *static_cast<ImS16 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U16:
    {
        ImU16 value = *reinterpret_cast<ImU16 *>(p_a) * *static_cast<ImU16 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S32:
    {
        ImS32 value = *reinterpret_cast<ImS32 *>(p_a) * *static_cast<ImS32 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U32:
    {
        ImU32 value = *reinterpret_cast<ImU32 *>(p_a) * *static_cast<ImU32 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S64:
    {
        ImS64 value = *reinterpret_cast<ImS64 *>(p_a) * *static_cast<ImS64 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U64:
    {
        ImU64 value = *reinterpret_cast<ImU64 *>(p_a) * *static_cast<ImU64 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_Float:
    {
        float value = *reinterpret_cast<float *>(p_a) * *static_cast<float *>(p_b);
        result      = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    case ImGuiDataType_Double:
    {
        double value = *reinterpret_cast<double *>(p_a) * *static_cast<double *>(p_b);
        result       = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    }

    return result;
}

ImU64 DivScalar(ImGuiDataType data_type, void *p_a, void *p_b)
{
    ImU64 result;
    switch (data_type)
    {
    case ImGuiDataType_S8:
    {
        ImS8 value = *reinterpret_cast<ImS8 *>(p_a) / *static_cast<ImS8 *>(p_b);
        result     = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U8:
    {
        ImU8 value = *reinterpret_cast<ImU8 *>(p_a) / *static_cast<ImU8 *>(p_b);
        result     = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S16:
    {
        ImS16 value = *reinterpret_cast<ImS16 *>(p_a) / *static_cast<ImS16 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U16:
    {
        ImU16 value = *reinterpret_cast<ImU16 *>(p_a) / *static_cast<ImU16 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S32:
    {
        ImS32 value = *reinterpret_cast<ImS32 *>(p_a) / *static_cast<ImS32 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U32:
    {
        ImU32 value = *reinterpret_cast<ImU32 *>(p_a) / *static_cast<ImU32 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S64:
    {
        ImS64 value = *reinterpret_cast<ImS64 *>(p_a) / *static_cast<ImS64 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U64:
    {
        ImU64 value = *reinterpret_cast<ImU64 *>(p_a) / *static_cast<ImU64 *>(p_b);
        result      = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_Float:
    {
        float value = *reinterpret_cast<float *>(p_a) / *static_cast<float *>(p_b);
        result      = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    case ImGuiDataType_Double:
    {
        double value = *reinterpret_cast<double *>(p_a) / *static_cast<double *>(p_b);
        result       = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    }

    return result;
}

ImU64 ClampScalar(ImGuiDataType data_type, void *p_value, void *p_min, void *p_max)
{
    ImU64 result = 0;
    switch (data_type)
    {
    case ImGuiDataType_S8:
    {
        ImS8 value =
            ImClamp(*reinterpret_cast<ImS8 *>(p_value), *static_cast<ImS8 *>(p_min), *static_cast<ImS8 *>(p_max));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U8:
    {
        ImU8 value =
            ImClamp(*reinterpret_cast<ImU8 *>(p_value), *static_cast<ImU8 *>(p_min), *static_cast<ImU8 *>(p_max));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S16:
    {
        ImS16 value =
            ImClamp(*reinterpret_cast<ImS16 *>(p_value), *static_cast<ImS16 *>(p_min), *static_cast<ImS16 *>(p_max));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U16:
    {
        ImU16 value =
            ImClamp(*reinterpret_cast<ImU16 *>(p_value), *static_cast<ImU16 *>(p_min), *static_cast<ImU16 *>(p_max));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S32:
    {
        ImS32 value =
            ImClamp(*reinterpret_cast<ImS32 *>(p_value), *static_cast<ImS32 *>(p_min), *static_cast<ImS32 *>(p_max));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U32:
    {
        ImU32 value =
            ImClamp(*reinterpret_cast<ImU32 *>(p_value), *static_cast<ImU32 *>(p_min), *static_cast<ImU32 *>(p_max));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S64:
    {
        ImS64 value =
            ImClamp(*reinterpret_cast<ImS64 *>(p_value), *static_cast<ImS64 *>(p_min), *static_cast<ImS64 *>(p_max));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U64:
    {
        ImU64 value =
            ImClamp(*reinterpret_cast<ImU64 *>(p_value), *static_cast<ImU64 *>(p_min), *static_cast<ImU64 *>(p_max));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_Float:
    {
        float value =
            ImClamp(*reinterpret_cast<float *>(p_value), *static_cast<float *>(p_min), *static_cast<float *>(p_max));
        result = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    case ImGuiDataType_Double:
    {
        double value =
            ImClamp(*reinterpret_cast<double *>(p_value), *static_cast<double *>(p_min), *static_cast<double *>(p_max));
        result = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    }

    return result;
}

ImU64 Normalize01(ImGuiDataType data_type, void *p_value, void const *p_min, void const *p_max)
{
    ImU64 result = 0;
    switch (data_type)
    {
    case ImGuiDataType_S8:
    {
        ImS8 value = (*reinterpret_cast<ImS8 *>(p_value) - *static_cast<ImS8 const *>(p_min)) /
                     (*static_cast<ImS8 const *>(p_max) - *static_cast<ImS8 const *>(p_min));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U8:
    {
        ImU8 value = (*reinterpret_cast<ImU8 *>(p_value) - *static_cast<ImU8 const *>(p_min)) /
                     (*static_cast<ImU8 const *>(p_max) - *static_cast<ImU8 const *>(p_min));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S16:
    {
        ImS16 value = (*reinterpret_cast<ImS16 *>(p_value) - *static_cast<ImS16 const *>(p_min)) /
                      (*static_cast<ImS16 const *>(p_max) - *static_cast<ImS16 const *>(p_min));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U16:
    {
        ImU16 value = (*reinterpret_cast<ImU16 *>(p_value) - *static_cast<ImU16 const *>(p_min)) /
                      (*static_cast<ImU16 const *>(p_max) - *static_cast<ImU16 const *>(p_min));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S32:
    {
        ImS32 value = (*reinterpret_cast<ImS32 *>(p_value) - *static_cast<ImS32 const *>(p_min)) /
                      (*static_cast<ImS32 const *>(p_max) - *static_cast<ImS32 const *>(p_min));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U32:
    {
        ImU32 value = (*reinterpret_cast<ImU32 *>(p_value) - *static_cast<ImU32 const *>(p_min)) /
                      (*static_cast<ImU32 const *>(p_max) - *static_cast<ImU32 const *>(p_min));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_S64:
    {
        ImS64 value = (*reinterpret_cast<ImS64 *>(p_value) - *static_cast<ImS64 const *>(p_min)) /
                      (*static_cast<ImS64 const *>(p_max) - *static_cast<ImS64 const *>(p_min));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_U64:
    {
        ImU64 value = (*reinterpret_cast<ImU64 *>(p_value) - *static_cast<ImU64 const *>(p_min)) /
                      (*static_cast<ImU64 const *>(p_max) - *static_cast<ImU64 const *>(p_min));
        result = static_cast<ImU64>(value);
    }
    break;
    case ImGuiDataType_Float:
    {
        float value = (*reinterpret_cast<float *>(p_value) - *static_cast<float const *>(p_min)) /
                      (*static_cast<float const *>(p_max) - *static_cast<float const *>(p_min));
        result = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    case ImGuiDataType_Double:
    {
        double value = (*reinterpret_cast<double *>(p_value) - *static_cast<double const *>(p_min)) /
                       (*static_cast<double const *>(p_max) - *static_cast<double const *>(p_min));
        result = *reinterpret_cast<ImU64 *>(&value);
    }
    break;
    }

    return result;
}

float Dot3(float x0, float x1, float x2, float *vec3) { return x0 * vec3[0] + x1 * vec3[1] + x2 * vec3[2]; }

void Mat33MulV(float *z0, float *z1, float *z2, float x, float y, float z, float *mat)
{
    *z0 = Dot3(x, y, z, &mat[0]);
    *z1 = Dot3(x, y, z, &mat[3]);
    *z2 = Dot3(x, y, z, &mat[6]);
}

float Dist2(ImVec2 const v, ImVec2 const w)
{
    // return Sqr(v.x - w.x) + Sqr(v.y - w.y);
    return ImLengthSqr(v - w);
}
float DistOnSegmentSqr(ImVec2 const p, ImVec2 const v, ImVec2 const w)
{
    float l2 = Dist2(v, w);
    // if (l2 == 0.0f)
    //	return 0.0f;

    float t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;

    return ImSaturate(t) * Dist2(w, v);
}
float DistToSegmentSqr(ImVec2 const p, ImVec2 const v, ImVec2 const w)
{
    // float l2 = Dist2(v, w);
    ////if (l2 == 0.0f)
    ////	return Dist2(p, v);
    //
    // float t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    // t = ImSaturate(t);
    //
    // return Dist2(p, ImVec2(v.x + t * (w.x - v.x),
    //					   v.y + t * (w.y - v.y)));

    float const lDx = v.x - w.x;
    float const lDy = v.y - w.y;

    float const dx = v.x - p.x;
    float const dy = v.y - p.y;

    float const l2 = ImSqrt(ImLengthSqr(w - v));

    return ImAbs(lDx * dy - lDy * dx) / l2;
}
float Side(ImVec2 const src, ImVec2 const tgt, ImVec2 const pts)
{
    ImVec2 vDir = tgt - src;
    ImVec2 vVec = pts - src;

    float zCross = vDir.x * vVec.y - vDir.y * vVec.x;

    return zCross >= 0.0f ? 1.0f : -1.0f;
}
ImVec2 Saturatev(ImVec2 const v) { return ImVec2(ImSaturate(v.x), ImSaturate(v.y)); }
ImVec2 Clampv(ImVec2 const v, ImVec2 const min, ImVec2 const max)
{
    return ImVec2(ImClamp(v.x, min.x, max.x), ImClamp(v.y, min.y, max.y));
}
float  Rescale01(float const x, float const min, float const max) { return (x - min) / (max - min); }
ImVec2 Rescale01v(ImVec2 const v, ImVec2 const min, ImVec2 const max)
{
    return ImVec2(Rescale01(v.x, min.x, max.x), Rescale01(v.y, min.y, max.y));
}
float Rescale(float const x, float const min, float const max, float const newMin, float const newMax)
{
    return Rescale01(x, min, max) * (newMax - newMin) + newMin;
}
ImVec2 Rescalev(ImVec2 const x, ImVec2 const min, ImVec2 const max, ImVec2 const newMin, ImVec2 const newMax)
{
    ImVec2 const vNorm = Rescale01v(x, min, max);
    return ImVec2(vNorm.x * (newMax.x - newMin.x) + newMin.x, vNorm.y * (newMax.y - newMin.y) + newMin.y);
}
float Sign(float x) { return x < 0.0f ? -1.0f : 1.0f; }
float ImLinearSample(float t, float *buffer, int count)
{
#if 0
		float const width = ( float )( count - 1 );

		float tx = ScaleFromNormalized( t, 0.0f, width );

		float i0 = ImFloor( tx );
		float i1 = ImCeil( tx );

		float t0 = i0 / width;
		float t1 = i1 / width;

		float ti;
		if ( t0 != t1 )
			ti = Normalize01( t, t0, t1 );
		else
			ti = 1.0f;

		return ImLerp( buffer[ ( int )i0 ], buffer[ ( int )i1 ], ti );
#else
    float const width = (float)(count - 1);

    float const i0 = ImFloor(t * width);
    float const i1 = ImCeil(t * width);

    float ti;
    if (i0 != i1)
        ti = (t * width - i0) / (i1 - i0);
    else
        ti = 1.0f;

    return ImLerp(buffer[(int)i0], buffer[(int)i1], ti);
#endif
}

void ColorConvertsRGBtosRGB(float &out_r, float &out_g, float &out_b, float r, float g, float b)
{
    out_r = r;
    out_g = g;
    out_b = b;
}
void ColorConvertRGBtoLinear(float &out_L, float &out_a, float &out_b, float r, float g, float b)
{
    out_L = ImsRGBToLinear(r);
    out_a = ImsRGBToLinear(g);
    out_b = ImsRGBToLinear(b);
    out_L = ImSaturate(out_L);
    out_a = ImSaturate(out_a);
    out_b = ImSaturate(out_b);
}
void ColorConvertLineartoRGB(float &out_r, float &out_g, float &out_b, float L, float a, float b)
{
    out_r = ImLinearTosRGB(L);
    out_g = ImLinearTosRGB(a);
    out_b = ImLinearTosRGB(b);
    out_r = ImSaturate(out_r);
    out_g = ImSaturate(out_g);
    out_b = ImSaturate(out_b);
}
void ColorConvertRGBtoOKLAB(float &out_L, float &out_a, float &out_b, float r, float g, float b)
{
    r       = ImsRGBToLinear(r);
    g       = ImsRGBToLinear(g);
    b       = ImsRGBToLinear(b);
    float l = 0.4122214708f * r + 0.5363325363f * g + 0.0514459929f * b;
    float m = 0.2119034982f * r + 0.6806995451f * g + 0.1073969566f * b;
    float s = 0.0883024619f * r + 0.2817188376f * g + 0.6299787005f * b;
    l       = ImCbrt(l);
    m       = ImCbrt(m);
    s       = ImCbrt(s);
    out_L   = l * +0.2104542553f + m * +0.7936177850f + s * -0.0040720468f;
    out_a   = l * +1.9779984951f + m * -2.4285922050f + s * +0.4505937099f;
    out_b   = l * +0.0259040371f + m * +0.7827717662f + s * -0.8086757660f;
}
void ColorConvertOKLABtoRGB(float &out_r, float &out_g, float &out_b, float L, float a, float b)
{
    float l = L + a * +0.3963377774f + b * +0.2158037573f;
    float m = L + a * -0.1055613458f + b * -0.0638541728f;
    float s = L + a * -0.0894841775f + b * -1.2914855480f;
    l       = l * l * l;
    m       = m * m * m;
    s       = s * s * s;
    out_r   = l * +4.0767416621f + m * -3.3077115913f + s * +0.2309699292f;
    out_g   = l * -1.2684380046f + m * +2.6097574011f + s * -0.3413193965f;
    out_b   = l * -0.0041960863f + m * -0.7034186147f + s * +1.7076147010f;
    out_r   = ImLinearTosRGB(out_r);
    out_g   = ImLinearTosRGB(out_g);
    out_b   = ImLinearTosRGB(out_b);
}
void ColorConvertOKLCHtoOKLAB(float &out_L, float &out_a, float &out_b, float r, float g, float b)
{
    out_L = r;
    out_a = g * ImCos(b * 2.0f * IM_PI);
    out_b = g * ImSin(b * 2.0f * IM_PI);
}
void ColorConvertOKLABtoOKLCH(float &out_r, float &out_g, float &out_b, float L, float a, float b)
{
    out_r = L;
    out_g = ImSqrt(a * a + b * b);
    out_b = ImAtan2(b, a);
    if (out_b < 0.0f)
    {
        out_b += 2.0f * IM_PI;
    }
    out_b /= 2.0f * IM_PI;
    out_b = ImSaturate(out_b);
}
void ColorConvertsRGBtoOKLCH(float &out_L, float &out_c, float &out_h, float r, float g, float b)
{
    float lL, la, lb;
    ColorConvertRGBtoOKLAB(lL, la, lb, r, g, b);
    ColorConvertOKLABtoOKLCH(out_L, out_c, out_h, lL, la, lb);
}
void ColorConvertOKLCHtosRGB(float &out_r, float &out_g, float &out_b, float L, float c, float h)
{
    float lL, la, lb;
    ColorConvertOKLCHtoOKLAB(lL, la, lb, L, c, h);
    ColorConvertOKLABtoRGB(out_r, out_g, out_b, lL, la, lb);
}

void ColorConvertRGBtoHSV(float &out_h, float &out_s, float &out_v, float r, float g, float b)
{
    ImGui::ColorConvertRGBtoHSV(r, g, b, out_h, out_s, out_v);
}

void ColorConvertHSVtoRGB(float &out_r, float &out_g, float &out_b, float h, float s, float v)
{
    ImGui::ColorConvertHSVtoRGB(h, s, v, out_r, out_g, out_b);
}

ImU32 KelvinTemperatureTosRGBColors(float temperature)
{
    float _r = ImFunctionFromData(temperature, s_min_kelvin_temp, s_max_kelvin_temp, s_kelvin_sRGB_Colors_Red,
                                  s_kelvin_temp_count);
    float _g = ImFunctionFromData(temperature, s_min_kelvin_temp, s_max_kelvin_temp, s_kelvin_sRGB_Colors_Green,
                                  s_kelvin_temp_count);
    float _b = ImFunctionFromData(temperature, s_min_kelvin_temp, s_max_kelvin_temp, s_kelvin_sRGB_Colors_Blue,
                                  s_kelvin_temp_count);

    ImU8 r = (ImU8)ImRound(_r);
    ImU8 g = (ImU8)ImRound(_g);
    ImU8 b = (ImU8)ImRound(_b);

    return IM_COL32(r, g, b, 255);
}

ImU32 ImColorFrom_xyz(float x, float y, float z, float *xyzToRGB, float gamma)
{
    float r, g, b;
    float maxValue;
    Mat33MulV(&r, &g, &b, x, y, z, xyzToRGB);
    maxValue = ImMax(r, ImMax(g, b));
    if (maxValue > 0.0f)
    {
        r /= maxValue;
        g /= maxValue;
        b /= maxValue;
    }
    r = ImSaturate(r);
    g = ImSaturate(g);
    b = ImSaturate(b);

    r = ImPow(r, gamma);
    g = ImPow(g, gamma);
    b = ImPow(b, gamma);

    return IM_COL32(r * 255, g * 255, b * 255, 255);
}

IMGUI_API ImU32 ImColorBlendsRGB(ImU32 col0, ImU32 col1, float t)
{
    ImVec4 v0 = ImGui::ColorConvertU32ToFloat4(col0);
    ImVec4 v1 = ImGui::ColorConvertU32ToFloat4(col1);

    ImVec4 o = ImLerp(v0, v1, t);

    return ImGui::GetColorU32(o);
}

//-----------------------------------------------------------------------------
// [SECTION] ImTriangulator, ImDrawList concave polygon fill
// COPY/PASTED FROM IMGUI_DRAW.CPP
//-----------------------------------------------------------------------------

enum ImTriangulatorNodeType0
{
    ImTriangulatorNodeType_Convex,
    ImTriangulatorNodeType_Ear,
    ImTriangulatorNodeType_Reflex
};

struct ImTriangulatorNode0
{
    ImTriangulatorNodeType0 Type;
    int                     Index;
    ImVec2                  Pos;
    ImTriangulatorNode0    *Next;
    ImTriangulatorNode0    *Prev;

    void Unlink()
    {
        Next->Prev = Prev;
        Prev->Next = Next;
    }
};

struct ImTriangulatorNodeSpan0
{
    ImTriangulatorNode0 **Data = NULL;
    int                   Size = 0;

    void push_back(ImTriangulatorNode0 *node) { Data[Size++] = node; }
    void find_erase_unsorted(int idx)
    {
        for (int i = Size - 1; i >= 0; i--)
            if (Data[i]->Index == idx)
            {
                Data[i] = Data[Size - 1];
                Size--;
                return;
            }
    }
};

struct ImTriangulator0
{
    static int EstimateTriangleCount(int points_count) { return (points_count < 3) ? 0 : points_count - 2; }
    static int EstimateScratchBufferSize(int points_count)
    {
        return sizeof(ImTriangulatorNode0) * points_count + sizeof(ImTriangulatorNode0 *) * points_count * 2;
    }

    void Init(const ImVec2 *points, int points_count, void *scratch_buffer);
    void GetNextTriangle(unsigned int out_triangle[3]); // Return relative indexes for next triangle

    // Internal functions
    void BuildNodes(const ImVec2 *points, int points_count);
    void BuildReflexes();
    void BuildEars();
    void FlipNodeList();
    bool IsEar(int i0, int i1, int i2, const ImVec2 &v0, const ImVec2 &v1, const ImVec2 &v2) const;
    void ReclassifyNode(ImTriangulatorNode0 *node);

    // Internal members
    int                     _TrianglesLeft = 0;
    ImTriangulatorNode0    *_Nodes         = NULL;
    ImTriangulatorNodeSpan0 _Ears;
    ImTriangulatorNodeSpan0 _Reflexes;
};

// Distribute storage for nodes, ears and reflexes.
// FIXME-OPT: if everything is convex, we could report it to caller and let it switch to an convex renderer
// (this would require first building reflexes to bail to convex if empty, without even building nodes)
void ImTriangulator0::Init(const ImVec2 *points, int points_count, void *scratch_buffer)
{
    IM_ASSERT(scratch_buffer != NULL && points_count >= 3);
    _TrianglesLeft = EstimateTriangleCount(points_count);
    _Nodes         = (ImTriangulatorNode0 *)scratch_buffer;                          // points_count x Node
    _Ears.Data     = (ImTriangulatorNode0 **)(_Nodes + points_count);                // points_count x Node*
    _Reflexes.Data = (ImTriangulatorNode0 **)(_Nodes + points_count) + points_count; // points_count x Node*
    BuildNodes(points, points_count);
    BuildReflexes();
    BuildEars();
}

void ImTriangulator0::BuildNodes(const ImVec2 *points, int points_count)
{
    for (int i = 0; i < points_count; i++)
    {
        _Nodes[i].Type  = ImTriangulatorNodeType_Convex;
        _Nodes[i].Index = i;
        _Nodes[i].Pos   = points[i];
        _Nodes[i].Next  = _Nodes + i + 1;
        _Nodes[i].Prev  = _Nodes + i - 1;
    }
    _Nodes[0].Prev                = _Nodes + points_count - 1;
    _Nodes[points_count - 1].Next = _Nodes;
}

void ImTriangulator0::BuildReflexes()
{
    ImTriangulatorNode0 *n1 = _Nodes;
    for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next)
    {
        if (ImTriangleIsClockwise(n1->Prev->Pos, n1->Pos, n1->Next->Pos))
            continue;
        n1->Type = ImTriangulatorNodeType_Reflex;
        _Reflexes.push_back(n1);
    }
}

void ImTriangulator0::BuildEars()
{
    ImTriangulatorNode0 *n1 = _Nodes;
    for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next)
    {
        if (n1->Type != ImTriangulatorNodeType_Convex)
            continue;
        if (!IsEar(n1->Prev->Index, n1->Index, n1->Next->Index, n1->Prev->Pos, n1->Pos, n1->Next->Pos))
            continue;
        n1->Type = ImTriangulatorNodeType_Ear;
        _Ears.push_back(n1);
    }
}

void ImTriangulator0::GetNextTriangle(unsigned int out_triangle[3])
{
    if (_Ears.Size == 0)
    {
        FlipNodeList();

        ImTriangulatorNode0 *node = _Nodes;
        for (int i = _TrianglesLeft; i >= 0; i--, node = node->Next) node->Type = ImTriangulatorNodeType_Convex;
        _Reflexes.Size = 0;
        BuildReflexes();
        BuildEars();

        // If we still don't have ears, it means geometry is degenerated.
        if (_Ears.Size == 0)
        {
            // Return first triangle available, mimicking the behavior of convex fill.
            IM_ASSERT(_TrianglesLeft > 0); // Geometry is degenerated
            _Ears.Data[0] = _Nodes;
            _Ears.Size    = 1;
        }
    }

    ImTriangulatorNode0 *ear = _Ears.Data[--_Ears.Size];
    out_triangle[0]          = ear->Prev->Index;
    out_triangle[1]          = ear->Index;
    out_triangle[2]          = ear->Next->Index;

    ear->Unlink();
    if (ear == _Nodes)
        _Nodes = ear->Next;

    ReclassifyNode(ear->Prev);
    ReclassifyNode(ear->Next);
    _TrianglesLeft--;
}

void ImTriangulator0::FlipNodeList()
{
    ImTriangulatorNode0 *prev    = _Nodes;
    ImTriangulatorNode0 *temp    = _Nodes;
    ImTriangulatorNode0 *current = _Nodes->Next;
    prev->Next                   = prev;
    prev->Prev                   = prev;
    while (current != _Nodes)
    {
        temp = current->Next;

        current->Next = prev;
        prev->Prev    = current;
        _Nodes->Next  = current;
        current->Prev = _Nodes;

        prev    = current;
        current = temp;
    }
    _Nodes = prev;
}

// A triangle is an ear is no other vertex is inside it. We can test reflexes vertices only (see reference algorithm)
bool ImTriangulator0::IsEar(int i0, int i1, int i2, const ImVec2 &v0, const ImVec2 &v1, const ImVec2 &v2) const
{
    ImTriangulatorNode0 **p_end = _Reflexes.Data + _Reflexes.Size;
    for (ImTriangulatorNode0 **p = _Reflexes.Data; p < p_end; p++)
    {
        ImTriangulatorNode0 *reflex = *p;
        if (reflex->Index != i0 && reflex->Index != i1 && reflex->Index != i2)
            if (ImTriangleContainsPoint(v0, v1, v2, reflex->Pos))
                return false;
    }
    return true;
}

void ImTriangulator0::ReclassifyNode(ImTriangulatorNode0 *n1)
{
    // Classify node
    ImTriangulatorNodeType0    type;
    const ImTriangulatorNode0 *n0 = n1->Prev;
    const ImTriangulatorNode0 *n2 = n1->Next;
    if (!ImTriangleIsClockwise(n0->Pos, n1->Pos, n2->Pos))
        type = ImTriangulatorNodeType_Reflex;
    else if (IsEar(n0->Index, n1->Index, n2->Index, n0->Pos, n1->Pos, n2->Pos))
        type = ImTriangulatorNodeType_Ear;
    else
        type = ImTriangulatorNodeType_Convex;

    // Update lists when a type changes
    if (type == n1->Type)
        return;
    if (n1->Type == ImTriangulatorNodeType_Reflex)
        _Reflexes.find_erase_unsorted(n1->Index);
    else if (n1->Type == ImTriangulatorNodeType_Ear)
        _Ears.find_erase_unsorted(n1->Index);
    if (type == ImTriangulatorNodeType_Reflex)
        _Reflexes.push_back(n1);
    else if (type == ImTriangulatorNodeType_Ear)
        _Ears.push_back(n1);
    n1->Type = type;
}

//////////////////////////////////////////////////////////////////////////
// Style
//////////////////////////////////////////////////////////////////////////
static ImWidgetsStyle s_Style;

ImWidgetsStyle &GetStyle() { return s_Style; }

void ImVectorUniqueEdge(int &size, ImVector<ImWidgetsEdgeIdx> &edges)
{
    size = edges.size();
    for (int p = 0; p < size; ++p)
    {
        for (int q = p + 1; q < size; ++q)
        {
            if (edges[p].a == edges[q].a && edges[p].b == edges[q].b)
            {
                while (edges[p].a == edges[q].a && edges[p].b == edges[q].b)
                {
                    // Flag non-unique edges with -index of the duplicate edge
                    edges[q].a = -p;
                    // edges[ q ].b = -p;
                    // ImEdgeIdx last = vector[ size - 1 ];
                    // vector[ size - 1 ] = vector[ q ];
                    // vector[ q ] = last;
                    --size;
                }
            }
        }
    }
    // vector.resize( size );
}

int GetEdgeIndex(ImVector<ImWidgetsEdgeIdx> const &edges, ImWidgetsEdgeIdx e)
{
    int edge_count = edges.size();
    for (int k = 0; k < edge_count; ++k)
    {
        ImWidgetsEdgeIdx const &cur = edges[k];
        if (cur.a == e.a && cur.b == e.b)
            return k;
    }

    return -1;
}

ImDrawIdx GetOtherIdx(ImDrawIdx a, ImDrawIdx b, ImWidgetsTriIdx &tri)
{
    if (a == tri.a)
    {
        if (b == tri.b)
        {
            return tri.c;
        }
        else if (b == tri.c)
        {
            return tri.b;
        }
    }
    else if (a == tri.b)
    {
        if (b == tri.a)
        {
            return tri.c;
        }
        else if (b == tri.c)
        {
            return tri.a;
        }
    }
    else if (a == tri.c)
    {
        if (b == tri.a)
        {
            return tri.b;
        }
        else if (b == tri.b)
        {
            return tri.a;
        }
    }

    return ImDrawIdx(-1);
}

void GetOtherIdxOrdered(ImDrawIdx &a, ImDrawIdx &b, ImWidgetsTriIdx &tri, ImDrawIdx p)
{
    if (p == tri.a)
    {
        a = tri.b;
        b = tri.c;
        return;
    }
    else if (p == tri.b)
    {
        a = tri.c;
        b = tri.a;
        return;
    }
    else if (p == tri.c)
    {
        a = tri.a;
        b = tri.b;
        return;
    }

    a = (ImDrawIdx)(-1);
    b = (ImDrawIdx)(-1);
}

float ImCross(ImVec2 v1, ImVec2 v2) { return v1.x * v2.y - v1.y * v2.x; }

float ImTriangleSignedArea(ImVec2 va, ImVec2 vb, ImVec2 vc)
{
    return 0.5f * (va.x * (vb.y - vc.y) + vb.x * (vc.y - va.y) + vc.x * (va.y - vb.y));
}

int CheckWinding(ImVec2 va, ImVec2 vb, ImVec2 vc)
{
    ImVec2 v1 = {vb.x - va.x, vb.y - va.y};
    ImVec2 v2 = {vc.x - va.x, vc.y - va.y};

    // float cross = ImCross( v1, v2 );
    float signed_area = ImTriangleSignedArea(va, vb, vc);

    if (signed_area > 0.0f)
    {
        // Counterclockwise (CCW)
        return 1;
    }
    else if (signed_area < 0.0f)
    {
        // Clockwise (CW)
        return -1;
    }
    else
    {
        // Collinear
        return 0;
    }
}

//////////////////////////////////////////////////////////////////////////
// Geometry Generation
//////////////////////////////////////////////////////////////////////////
#ifdef DEAR_WIDGETS_TESSELATION
// #pragma optimize( "", off )
void ShapeTesselationUniform(ImWidgetsShape &shape)
{
    int vtx_count = shape.vertices.size();
    int tri_count = shape.triangles.size();

    typedef std::pair<ImDrawIdx, ImDrawIdx> Edge;
    std::map<Edge, ImWidgetsVertex>         edge_to_vrtx;
    for (int k = 0; k < tri_count; ++k)
    {
        ImWidgetsTriIdx const &tri = shape.triangles[k];

        ImDrawIdx a = tri.a;
        ImDrawIdx b = tri.b;
        ImDrawIdx c = tri.c;

        ImVec2 va = shape.vertices[a].pos;
        ImVec2 vb = shape.vertices[b].pos;
        ImVec2 vc = shape.vertices[c].pos;

        ImVec2 uva = shape.vertices[a].uv;
        ImVec2 uvb = shape.vertices[b].uv;
        ImVec2 uvc = shape.vertices[c].uv;

        ImVec4 cola = ImGui::ColorConvertU32ToFloat4(shape.vertices[a].col);
        ImVec4 colb = ImGui::ColorConvertU32ToFloat4(shape.vertices[b].col);
        ImVec4 colc = ImGui::ColorConvertU32ToFloat4(shape.vertices[c].col);

        Edge ab = {ImMin(a, b), ImMax(a, b)};
        Edge bc = {ImMin(b, c), ImMax(b, c)};
        Edge ca = {ImMin(c, a), ImMax(c, a)};

        float ab_sqr = ImLengthSqr(va - vb);
        float bc_sqr = ImLengthSqr(vb - vc);
        float ca_sqr = ImLengthSqr(vc - va);

        if (ab_sqr >= bc_sqr && ab_sqr >= ca_sqr)
        {
            ImVec2 v         = va * 0.5f + vb * 0.5f;
            ImVec2 uv        = uva * 0.5f + uvb * 0.5f;
            ImVec4 col       = ImLerp(cola, colb, 0.5f);
            edge_to_vrtx[ab] = {v, uv, ImGui::GetColorU32(col)};
        }
        else if (bc_sqr >= ab_sqr && bc_sqr >= ca_sqr)
        {
            ImVec2 v         = vb * 0.5f + vc * 0.5f;
            ImVec2 uv        = uvb * 0.5f + uvc * 0.5f;
            ImVec4 col       = ImLerp(colb, colc, 0.5f);
            edge_to_vrtx[bc] = {v, uv, ImGui::GetColorU32(col)};
        }
        else if (ca_sqr >= ab_sqr && ca_sqr >= bc_sqr)
        {
            ImVec2 v         = vc * 0.5f + va * 0.5f;
            ImVec2 uv        = uvc * 0.5f + uva * 0.5f;
            ImVec4 col       = ImLerp(colc, cola, 0.5f);
            edge_to_vrtx[ca] = {v, uv, ImGui::GetColorU32(col)};
        }
        else
        {
            __debugbreak();
        }
    }
    int                 new_vrtx_count = 0;
    std::map<Edge, int> edge_to_idx;
    for (auto const &x : edge_to_vrtx)
    {
        edge_to_idx[x.first] = vtx_count + new_vrtx_count;
        ++new_vrtx_count;
    }
    shape.vertices.resize(vtx_count + new_vrtx_count);
    int vidx = 0;
    for (auto const &x : edge_to_vrtx)
    {
        shape.vertices[vtx_count + vidx] = x.second;
        ++vidx;
    }

    ImVector<ImWidgetsTriIdx> new_indices;
    for (int k = 0; k < tri_count; ++k)
    {
        ImWidgetsTriIdx const &tri = shape.triangles[k];

        ImDrawIdx a = tri.a;
        ImDrawIdx b = tri.b;
        ImDrawIdx c = tri.c;

        Edge ab = {ImMin(a, b), ImMax(a, b)};
        Edge bc = {ImMin(b, c), ImMax(b, c)};
        Edge ca = {ImMin(c, a), ImMax(c, a)};

        bool is_ab          = false;
        bool is_bc          = false;
        bool is_ca          = false;
        int  new_vrtx_count = 0;
        if (edge_to_vrtx.find(ab) != edge_to_vrtx.end())
        {
            ++new_vrtx_count;
            is_ab = true;
        }
        if (edge_to_vrtx.find(bc) != edge_to_vrtx.end())
        {
            ++new_vrtx_count;
            is_bc = true;
        }
        if (edge_to_vrtx.find(ca) != edge_to_vrtx.end())
        {
            ++new_vrtx_count;
            is_ca = true;
        }
        if (new_vrtx_count == 0)
        {
            new_indices.push_back({a, b, c});
            __debugbreak();
        }
        else if (new_vrtx_count == 1)
        {
            if (is_ab)
            {
                ImDrawIdx new_ab = edge_to_idx[ab];
                IM_ASSERT(new_ab > vtx_count);
                new_indices.push_back({a, new_ab, c});
                new_indices.push_back({c, new_ab, b});
            }
            else if (is_bc)
            {
                ImDrawIdx new_bc = edge_to_idx[bc];
                IM_ASSERT(new_bc > vtx_count);
                new_indices.push_back({b, new_bc, a});
                new_indices.push_back({a, new_bc, c});
            }
            else if (is_ca)
            {
                ImDrawIdx new_ca = edge_to_idx[ca];
                IM_ASSERT(new_ca > vtx_count);
                new_indices.push_back({c, new_ca, b});
                new_indices.push_back({b, new_ca, a});
            }
            else
            {
                __debugbreak();
            }
        }
        else if (new_vrtx_count == 2)
        {
            if (is_ab && is_bc)
            {
                ImDrawIdx new_ab = edge_to_idx[ab];
                ImDrawIdx new_bc = edge_to_idx[bc];
                IM_ASSERT(new_ab > vtx_count);
                IM_ASSERT(new_bc > vtx_count);
                new_indices.push_back({a, new_ab, new_bc});
                new_indices.push_back({b, new_bc, new_ab});
                new_indices.push_back({c, a, new_bc});
            }
            else if (is_bc && is_ca)
            {
                ImDrawIdx new_bc = edge_to_idx[bc];
                ImDrawIdx new_ca = edge_to_idx[ca];
                IM_ASSERT(new_bc > vtx_count);
                IM_ASSERT(new_ca > vtx_count);
                new_indices.push_back({b, new_bc, new_ca});
                new_indices.push_back({a, b, new_ca});
                new_indices.push_back({c, new_ca, new_bc});
            }
            else if (is_ca && is_ab)
            {
                ImDrawIdx new_ab = edge_to_idx[ab];
                ImDrawIdx new_ca = edge_to_idx[ca];
                IM_ASSERT(new_ab > vtx_count);
                IM_ASSERT(new_ca > vtx_count);
                new_indices.push_back({a, new_ab, new_ca});
                new_indices.push_back({c, new_ca, new_ab});
                new_indices.push_back({b, c, new_ab});
            }
            else
            {
                __debugbreak();
            }
        }
        else if (new_vrtx_count == 3)
        {
            ImDrawIdx new_ab = edge_to_idx[ab];
            ImDrawIdx new_bc = edge_to_idx[bc];
            ImDrawIdx new_ca = edge_to_idx[ca];
            IM_ASSERT(new_ab > vtx_count);
            IM_ASSERT(new_bc > vtx_count);
            IM_ASSERT(new_ca > vtx_count);

            new_indices.push_back({a, new_ab, new_ca});
            new_indices.push_back({b, new_bc, new_ab});
            new_indices.push_back({c, new_ca, new_bc});
            new_indices.push_back({new_ab, new_bc, new_ca});
        }
        else
        {
            __debugbreak();
        }
    }
    int new_tri_count = new_indices.size();
    for (int k = 0; k < new_tri_count; ++k)
    {
        ImWidgetsTriIdx &tri = new_indices[k];

        ImDrawIdx a = tri.a;
        ImDrawIdx b = tri.b;
        ImDrawIdx c = tri.c;

        ImVec2 va = shape.vertices[a].pos;
        ImVec2 vb = shape.vertices[b].pos;
        ImVec2 vc = shape.vertices[c].pos;

        if (CheckWinding(va, vb, vc) == -1)
        {
            // tri.a = a;
            tri.b = c;
            tri.c = b;
        }
    }
    shape.triangles = new_indices;
}
#endif

void ShapeTranslate(ImWidgetsShape &shape, ImVec2 t)
{
    int vtx_count = shape.vertices.size();
    for (int k = 0; k < vtx_count; ++k) { shape.vertices[k].pos += t; }
    shape.bb.Min += t;
    shape.bb.Max += t;
}

void ShapeSetDefaultUV(ImWidgetsShape &shape)
{
    int vtx_count = shape.vertices.size();
    for (int k = 0; k < vtx_count; ++k) { shape.vertices[k].uv = ImGui::GetFontTexUvWhitePixel(); }
}

void ShapeSetDefaultUVCol(ImWidgetsShape &shape)
{
    int vtx_count = shape.vertices.size();
    for (int k = 0; k < vtx_count; ++k)
    {
        shape.vertices[k].uv  = ImGui::GetFontTexUvWhitePixel();
        shape.vertices[k].col = IM_COL32(255, 255, 255, 255);
    }
}

void ShapeSetDefaultBoundUV(ImWidgetsShape &shape)
{
    int vtx_count = shape.vertices.size();
    for (int k = 0; k < vtx_count; ++k)
    {
        ImVec2 v = shape.vertices[k].pos;
        ImVec2 uv;
        uv.x                 = Normalize01(v.x, shape.bb.Min.x, shape.bb.Max.x);
        uv.y                 = Normalize01(v.y, shape.bb.Min.y, shape.bb.Max.y);
        shape.vertices[k].uv = uv;
    }
}

void ShapeSetDefaultBoundUVWhiteCol(ImWidgetsShape &shape)
{
    int vtx_count = shape.vertices.size();
    for (int k = 0; k < vtx_count; ++k)
    {
        ImVec2 v = shape.vertices[k].pos;
        ImVec2 uv;
        uv.x                  = Normalize01(v.x, shape.bb.Min.x, shape.bb.Max.x);
        uv.y                  = Normalize01(v.y, shape.bb.Min.y, shape.bb.Max.y);
        shape.vertices[k].uv  = uv;
        shape.vertices[k].col = IM_COL32(255, 255, 255, 255);
    }
}

void ShapeSetDefaultWhiteCol(ImWidgetsShape &shape)
{
    int vtx_count = shape.vertices.size();
    for (int k = 0; k < vtx_count; ++k) { shape.vertices[k].col = IM_COL32(255, 255, 255, 255); }
}

void ShapeSetBound(ImWidgetsShape &shape)
{
    shape.bb.Min  = shape.vertices.front().pos;
    shape.bb.Max  = shape.vertices.front().pos;
    int vtx_count = shape.vertices.size();
    for (int k = 1; k < vtx_count; ++k)
    {
        shape.bb.Min.x = ImMin(shape.bb.Min.x, shape.vertices[k].pos.x);
        shape.bb.Min.y = ImMin(shape.bb.Min.y, shape.vertices[k].pos.y);
        shape.bb.Max.x = ImMax(shape.bb.Max.x, shape.vertices[k].pos.x);
        shape.bb.Max.y = ImMax(shape.bb.Max.y, shape.vertices[k].pos.y);
    }
}

void ShapeLineSetBound(ImWidgetsShapeLine &shape)
{
    shape.bb.Min = shape.vertices.front().pos;
    shape.bb.Max = shape.vertices.front().pos;
    // shape.bb.Min = shape.vertices->pos;
    // shape.bb.Max = shape.vertices->pos;
    int vtx_count = shape.vertices.size();
    // int vtx_count = shape.vertices_count;
    for (int k = 1; k < vtx_count; ++k)
    {
        shape.bb.Min.x = ImMin(shape.bb.Min.x, shape.vertices[k].pos.x);
        shape.bb.Min.y = ImMin(shape.bb.Min.y, shape.vertices[k].pos.y);
        shape.bb.Max.x = ImMin(shape.bb.Max.x, shape.vertices[k].pos.x);
        shape.bb.Max.y = ImMin(shape.bb.Max.y, shape.vertices[k].pos.y);
    }
}

void GenShapeRect(ImWidgetsShape &shape, ImRect const &r)
{
    shape.vertices.clear();
    shape.triangles.clear();
    shape.vertices.resize(4);
    shape.triangles.resize(2);
    shape.vertices[0].pos = r.Min;
    shape.vertices[1].pos = ImVec2(r.Min.x, r.Max.y);
    shape.vertices[2].pos = r.Max;
    shape.vertices[3].pos = ImVec2(r.Max.x, r.Min.y);
    shape.bb              = r;

    shape.triangles[0].a = 0;
    shape.triangles[0].b = 1;
    shape.triangles[0].c = 3;
    shape.triangles[1].a = 3;
    shape.triangles[1].b = 1;
    shape.triangles[1].c = 2;
}

void GenShapeCircle(ImWidgetsShape &shape, ImVec2 center, float radius, int side_count)
{
    shape.vertices.clear();
    shape.triangles.clear();
    float d0 = 2.0f * IM_PI / ((float)(side_count));
    shape.vertices.resize(side_count + 1);
    shape.triangles.resize(side_count);
    shape.vertices[0].pos = center;
    for (int k = 0; k < side_count; ++k)
    {
        float _0                    = ((float)k) * d0;
        shape.vertices[k + 1].pos.x = center.x + radius * ImCos(_0);
        shape.vertices[k + 1].pos.y = center.y + radius * ImSin(_0);
    }
    for (int k = 0; k < side_count; ++k)
    {
        shape.triangles[k].a = 0;
        shape.triangles[k].b = (k + 1) % side_count + 1;
        shape.triangles[k].c = (k + 2) % side_count + 1;
    }
    shape.bb.Min = center - ImVec2(radius, radius);
    shape.bb.Max = center + ImVec2(radius, radius);
}
void GenShapeCircleArc(ImWidgetsShape &shape, ImVec2 center, float radius, float angle_min, float angle_max,
                       int side_count)
{
    shape.vertices.clear();
    shape.triangles.clear();
    float angle_range = angle_max - angle_min;
    float d0          = angle_range / ((float)(side_count));
    shape.vertices.resize(side_count + 2);
    shape.triangles.resize(side_count);
    shape.vertices[0].pos = center;
    shape.bb.Min.x        = FLT_MAX;
    shape.bb.Min.y        = FLT_MAX;
    shape.bb.Max.x        = -FLT_MAX;
    shape.bb.Max.y        = -FLT_MAX;
    for (int k = 0; k < side_count + 2; ++k)
    {
        float  _0 = angle_min + ((float)k) * d0;
        ImVec2 v;
        v.x                         = center.x + radius * ImCos(-_0);
        v.y                         = center.y + radius * ImSin(-_0);
        shape.vertices[k + 1].pos.x = v.x;
        shape.vertices[k + 1].pos.y = v.y;
        shape.bb.Min.x              = ImMin(shape.bb.Min.x, v.x);
        shape.bb.Min.y              = ImMin(shape.bb.Min.y, v.y);
        shape.bb.Max.x              = ImMax(shape.bb.Max.x, v.x);
        shape.bb.Max.y              = ImMax(shape.bb.Max.y, v.y);
    }
    for (int k = 0; k < side_count; ++k)
    {
        shape.triangles[k].a = 0;
        shape.triangles[k].b = k + 1;
        shape.triangles[k].c = k + 2;
    }
}
void GenShapeRegularNGon(ImWidgetsShape &shape, ImVec2 center, float radius, int side_count)
{
    GenShapeCircle(shape, center, radius, side_count);
}

void ShapeLinearGradientGeneric(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1,
                                pfSpace2sRGB space2sRGB, pfsRGB2Space sRGB2Space)
{
    ImVec2 delta     = uv_end - uv_start;
    ImVec2 d         = ImNormalized(delta);
    float  l         = 1.0f / ImLength(delta);
    int    vtx_count = shape.vertices.size();
    ImVec4 col0v     = ImGui::ColorConvertU32ToFloat4(col0);
    ImVec4 col1v     = ImGui::ColorConvertU32ToFloat4(col1);
    ImVec4 col0k;
    ImVec4 col1k;
    col0k.w = col0v.w;
    col1k.w = col1v.w;
    sRGB2Space(col0k.x, col0k.y, col0k.z, col0v.x, col0v.y, col0v.z);
    sRGB2Space(col1k.x, col1k.y, col1k.z, col1v.x, col1v.y, col1v.z);
    ImVec4 vtxCol;
    for (int k = 0; k < vtx_count; ++k)
    {
        ImVec2 v = shape.vertices[k].pos;
        ImVec2 uv;
        uv.x          = Normalize01(v.x, shape.bb.Min.x, shape.bb.Max.x);
        uv.y          = Normalize01(v.y, shape.bb.Min.y, shape.bb.Max.y);
        ImVec2 c      = uv - uv_start;
        float  t      = ImSaturate(ImDot(d, c) * l);
        ImVec4 curCol = ImLerp(col0k, col1k, t);
        vtxCol.w      = curCol.w;
        space2sRGB(vtxCol.x, vtxCol.y, vtxCol.z, curCol.x, curCol.y, curCol.z);
        shape.vertices[k].col = ImGui::GetColorU32(vtxCol);
    }
}
void ShapeRadialGradientGeneric(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1,
                                pfSpace2sRGB space2sRGB, pfsRGB2Space sRGB2Space)
{
    ImVec2 delta     = uv_end - uv_start;
    float  l         = 1.0f / ImLength(delta);
    int    vtx_count = shape.vertices.size();
    ImVec4 col0v     = ImGui::ColorConvertU32ToFloat4(col0);
    ImVec4 col1v     = ImGui::ColorConvertU32ToFloat4(col1);
    ImVec4 col0k;
    ImVec4 col1k;
    col0k.w = col0v.w;
    col1k.w = col1v.w;
    sRGB2Space(col0k.x, col0k.y, col0k.z, col0v.x, col0v.y, col0v.z);
    sRGB2Space(col1k.x, col1k.y, col1k.z, col1v.x, col1v.y, col1v.z);
    ImVec4 vtxCol;
    for (int k = 0; k < vtx_count; ++k)
    {
        ImVec2 v = shape.vertices[k].pos;
        ImVec2 uv;
        uv.x          = Normalize01(v.x, shape.bb.Min.x, shape.bb.Max.x);
        uv.y          = Normalize01(v.y, shape.bb.Min.y, shape.bb.Max.y);
        float  t      = ImSaturate(ImLength(uv - uv_start) * l);
        ImVec4 curCol = ImLerp(col0k, col1k, t);
        vtxCol.w      = curCol.w;
        space2sRGB(vtxCol.x, vtxCol.y, vtxCol.z, curCol.x, curCol.y, curCol.z);
        shape.vertices[k].col = ImGui::GetColorU32(vtxCol);
    }
}
// Just L1-Norm
void ShapeDiamondGradientGeneric(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1,
                                 pfSpace2sRGB space2sRGB, pfsRGB2Space sRGB2Space)
{
    ImVec2 delta     = uv_end - uv_start;
    float  l         = 1.0f / ImLengthL1(delta);
    int    vtx_count = shape.vertices.size();
    ImVec4 col0v     = ImGui::ColorConvertU32ToFloat4(col0);
    ImVec4 col1v     = ImGui::ColorConvertU32ToFloat4(col1);
    ImVec4 col0k;
    ImVec4 col1k;
    col0k.w = col0v.w;
    col1k.w = col1v.w;
    sRGB2Space(col0k.x, col0k.y, col0k.z, col0v.x, col0v.y, col0v.z);
    sRGB2Space(col1k.x, col1k.y, col1k.z, col1v.x, col1v.y, col1v.z);
    ImVec4 vtxCol;
    for (int k = 0; k < vtx_count; ++k)
    {
        ImVec2 v = shape.vertices[k].pos;
        ImVec2 uv;
        uv.x          = Normalize01(v.x, shape.bb.Min.x, shape.bb.Max.x);
        uv.y          = Normalize01(v.y, shape.bb.Min.y, shape.bb.Max.y);
        float  t      = ImSaturate(ImLengthL1(uv - uv_start) * l);
        ImVec4 curCol = ImLerp(col0k, col1k, t);
        vtxCol.w      = curCol.w;
        space2sRGB(vtxCol.x, vtxCol.y, vtxCol.z, curCol.x, curCol.y, curCol.z);
        shape.vertices[k].col = ImGui::GetColorU32(vtxCol);
    }
}

void ShapeSRGBLinearGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    // ImVec2 delta = uv_end - uv_start;
    // ImVec2 d = ImNormalized( delta );
    // float l = 1.0f / ImLength( delta );
    // int vtx_count = shape.vertices.size();
    // for ( int k = 0; k < vtx_count; ++k )
    //{
    //	ImVec2 v = shape.vertices[ k ].pos;
    //	ImVec2 uv;
    //	uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
    //	uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
    //	ImVec2 c = uv - uv_start;
    //	float t = ImSaturate( ImDot( d, c ) * l );
    //	shape.vertices[ k ].col = ImColorBlendsRGB( col0, col1, t );
    // }
    ShapeLinearGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertsRGBtosRGB, &ColorConvertsRGBtosRGB);
}
void ShapeSRGBRadialGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    // ImVec2 delta = uv_end - uv_start;
    // float l = 1.0f / ImLength( delta );
    // int vtx_count = shape.vertices.size();
    // for ( int k = 0; k < vtx_count; ++k )
    //{
    //	ImVec2 v = shape.vertices[ k ].pos;
    //	ImVec2 uv;
    //	uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
    //	uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
    //	float t = ImSaturate( ImLength( uv - uv_start ) * l );
    //	shape.vertices[ k ].col = ImColorBlendsRGB( col0, col1, t );
    // }
    ShapeRadialGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertsRGBtosRGB, &ColorConvertsRGBtosRGB);
}
// Just L1-Norm
void ShapeSRGBDiamondGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    // ImVec2 delta = uv_end - uv_start;
    // float l = 1.0f / ImLengthL1( delta );
    // int vtx_count = shape.vertices.size();
    // for ( int k = 0; k < vtx_count; ++k )
    //{
    //	ImVec2 v = shape.vertices[ k ].pos;
    //	ImVec2 uv;
    //	uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
    //	uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
    //	float t = ImSaturate( ImLengthL1( uv - uv_start ) * l );
    //	shape.vertices[ k ].col = ImColorBlendsRGB( col0, col1, t );
    // }
    ShapeDiamondGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertsRGBtosRGB, &ColorConvertsRGBtosRGB);
}
void ShapeOkLabLinearGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeLinearGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertOKLABtoRGB, &ColorConvertRGBtoOKLAB);
}
void ShapeOkLabRadialGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeRadialGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertOKLABtoRGB, &ColorConvertRGBtoOKLAB);
}
void ShapeOkLabDiamondGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeDiamondGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertOKLABtoRGB, &ColorConvertRGBtoOKLAB);
}

void ShapeOkLchLinearGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeLinearGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertOKLCHtosRGB, &ColorConvertsRGBtoOKLCH);
}
void ShapeOkLchRadialGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeRadialGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertOKLCHtosRGB, &ColorConvertsRGBtoOKLCH);
}
void ShapeOkLchDiamondGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeDiamondGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertOKLCHtosRGB,
                                &ColorConvertsRGBtoOKLCH);
}

void ShapeLinearSRGBLinearGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeLinearGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertLineartoRGB, &ColorConvertRGBtoLinear);
}
void ShapeLinearSRGBRadialGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeRadialGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertLineartoRGB, &ColorConvertRGBtoLinear);
}
void ShapeLinearSRGBDiamondGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeDiamondGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertLineartoRGB,
                                &ColorConvertRGBtoLinear);
}

void ShapeHSVLinearGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeLinearGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertHSVtoRGB, &ColorConvertRGBtoHSV);
}
void ShapeHSVRadialGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeRadialGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertHSVtoRGB, &ColorConvertRGBtoHSV);
}
void ShapeHSVDiamondGradient(ImWidgetsShape &shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1)
{
    ShapeDiamondGradientGeneric(shape, uv_start, uv_end, col0, col1, &ColorConvertHSVtoRGB, &ColorConvertRGBtoHSV);
}

//////////////////////////////////////////////////////////////////////////
// ImWidgets Context
//////////////////////////////////////////////////////////////////////////
static ImWidgetsContext *gs_pContext = NULL;

void CreateMarkersShaders(ImWidgetsContext *ctx)
{
    ImWidgetsMarkerBuffer markerParams;
    markerParams.fg_color     = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
    markerParams.bg_color     = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
    markerParams.rotation     = ImVec2(ImCos(0.0f), ImSin(0.0f));
    markerParams.linewidth    = 0.5f;
    markerParams.size         = 0.5f;
    markerParams.type         = (float)ImWidgetsMarker_Disc;
    markerParams.antialiasing = 0.0f;
    markerParams.draw_type    = 0.0f;
    markerParams.pad0         = 0.0f;

    // CreateInternalShader( &ctx->markerShader, "markers", 0, NULL, sizeof( ImWidgetsMarkerBuffer ), &markerParams );

    //		char* vs_source;
    //		char* ps_source;
    //
    // #define FILENAME_BUF 512
    //		char filename_vs[ FILENAME_BUF ];
    //		char filename_ps[ FILENAME_BUF ];
    //
    // #if IM_CURRENT_GFX == IM_GFX_OPENGL3 || IM_CURRENT_GFX == IM_GFX_VULKAN
    //		ImFormatString( filename_vs, FILENAME_BUF, "./shaders/%s/markers_vs.%s", "glsl", "glsl" );
    //		ImFormatString( filename_ps, FILENAME_BUF, "./shaders/%s/markers_ps.%s", "glsl", "glsl" );
    // #elif IM_CURRENT_GFX == IM_GFX_DIRECTX9 || IM_CURRENT_GFX == IM_GFX_DIRECTX10 || IM_CURRENT_GFX ==
    // IM_GFX_DIRECTX11 || IM_CURRENT_GFX == IM_GFX_DIRECTX12 		ImFormatString( filename_vs, FILENAME_BUF,
    //"./shaders/%s/markers.%s", "hlsl_src", "hlsl" ); 		ImFormatString( filename_ps, FILENAME_BUF,
    //"./shaders/%s/markers.%s", "hlsl_src", "hlsl" ); #elif IM_CURRENT_GFX == IM_GFX_METAL 		ImFormatString(
    //filename_vs, FILENAME_BUF, "./shaders/%s/markers_vs.%s", "msl", "msl" ); 		ImFormatString( filename_ps,
    // FILENAME_BUF,
    //"./shaders/%s/markers_ps.%s", "msl", "msl" ); #endif
    //
    //		size_t file_data_size_vs;
    //		size_t file_data_size_ps;
    //		LoadShaderFile( &file_data_size_vs, &vs_source, filename_vs );
    //		LoadShaderFile( &file_data_size_ps, &ps_source, filename_ps );
    //
    //		ctx->markerShader = ImPlatform::CreateShader( vs_source, ps_source, 0, NULL, sizeof( ImWidgetsMarkerBuffer
    //), &markerParams ); 		IM_FREE( vs_source ); 		IM_FREE( ps_source );
}

void SetFeatures(ImWidgetsFeatures features) { GlobalData.features = features; }

void AddFeatures(ImWidgetsFeatures features) { GlobalData.features |= features; }

void RemoveFeature(ImWidgetsFeatures features) { GlobalData.features &= ~features; }

ImWidgetsContext *CreateContext()
{
    ImWidgetsContext *ctx = IM_NEW(ImWidgetsContext);
    // if ( GlobalData.features & ImWidgetsFeatures_Markers )
    // 	ImPlatform::SetFeatures( ImPlatformFeatures_CustomShader );

    if (gs_pContext == NULL)
        gs_pContext = ctx;

    // int width;
    // int height;
    // width = height = 4;
    // int channel = 4;
    // ImU8* black_data = ( ImU8* )IM_ALLOC( width * height * channel );
    // ImU8* white_data = ( ImU8* )IM_ALLOC( width * height * channel );
    // for ( int j = 0; j < height; ++j )
    // {
    // 	for ( int i = 0; i < width; ++i )
    // 	{
    // 		black_data[ channel * ( j * height + i ) + 0 ] = 0x00u;
    // 		black_data[ channel * ( j * height + i ) + 1 ] = 0x00u;
    // 		black_data[ channel * ( j * height + i ) + 2 ] = 0x00u;
    // 		black_data[ channel * ( j * height + i ) + 3 ] = 0xFFu;

    // 		white_data[ channel * ( j * height + i ) + 0 ] = 0xFFu;
    // 		white_data[ channel * ( j * height + i ) + 1 ] = 0xFFu;
    // 		white_data[ channel * ( j * height + i ) + 2 ] = 0xFFu;
    // 		white_data[ channel * ( j * height + i ) + 3 ] = 0xFFu;
    // 	}
    // }
    // ImTextureID img_white = ImPlatform::CreateTexture2D( ( char* )white_data, width, height,
    // 													 {
    // 														ImPixelChannel_RGBA,
    // 														ImPixelType_UInt8,
    // 														ImTextureFiltering_Linear,
    // 														ImTextureBoundary_Clamp,
    // 														ImTextureBoundary_Clamp
    // 													 } );
    // ImTextureID img_black = ImPlatform::CreateTexture2D( ( char* )black_data, width, height,
    // 													 {
    // 														ImPixelChannel_RGBA,
    // 														ImPixelType_UInt8,
    // 														ImTextureFiltering_Linear,
    // 														ImTextureBoundary_Clamp,
    // 														ImTextureBoundary_Clamp
    // 													 } );
    // IM_FREE( black_data );
    // IM_FREE( white_data );

    // ctx->blackImg = img_black;
    // ctx->whiteImg = img_white;

    // OwnTexture( img_black );
    // OwnTexture( img_white );

    // if ( GlobalData.features & ImWidgetsFeatures_Markers )
    // 	CreateMarkersShaders( ctx );

    return ctx;
}
// void	OwnTexture( ImTextureID tex )
// {
// 	gs_pContext->ressources.push_back( tex );
// }

void DestroyContext(ImWidgetsContext *ctx)
{
    if (ctx != NULL)
    {
        IM_DELETE(ctx);
    }
    // int img_count = gs_pContext->ressources.size();
    // for ( int k = 0; k < img_count; ++k )
    // {
    // 	ImPlatform::ReleaseTexture2D( gs_pContext->ressources[ k ] );
    // }
}

void SetCurrentContext(ImWidgetsContext *ctx) { gs_pContext = ctx; }

//////////////////////////////////////////////////////////////////////////
// DrawList
//////////////////////////////////////////////////////////////////////////

void DrawShapeEx(ImDrawList *pDrawList, ImTextureID tex, ImWidgetsShape &shape)
{
    const bool push_texture_id = true; // tex != pDrawList->_CmdHeader.TextureId;
    if (push_texture_id)
        pDrawList->PushTextureID(tex);

    int vtx_count = shape.vertices.size();
    int tri_count = shape.triangles.size();
    pDrawList->PrimReserve(3 * tri_count, vtx_count);
    for (int k = 0; k < vtx_count; k++)
    {
        ImWidgetsVertex const &v       = shape.vertices[k];
        pDrawList->_VtxWritePtr[0].pos = v.pos;
        pDrawList->_VtxWritePtr[0].uv  = v.uv;
        pDrawList->_VtxWritePtr[0].col = v.col;
        pDrawList->_VtxWritePtr++;
    }
    for (int k = 0; k < tri_count; k++)
    {
        pDrawList->_IdxWritePtr[0] = (ImDrawIdx)(pDrawList->_VtxCurrentIdx + shape.triangles[k].a);
        pDrawList->_IdxWritePtr[1] = (ImDrawIdx)(pDrawList->_VtxCurrentIdx + shape.triangles[k].b);
        pDrawList->_IdxWritePtr[2] = (ImDrawIdx)(pDrawList->_VtxCurrentIdx + shape.triangles[k].c);
        pDrawList->_IdxWritePtr += 3;
    }
    pDrawList->_VtxCurrentIdx += (ImDrawIdx)vtx_count;

    if (push_texture_id)
        pDrawList->PopTextureID();
}

void DrawImageShape(ImDrawList *pDrawList, ImTextureID tex, ImWidgetsShape &shape)
{
    DrawShapeEx(pDrawList, tex, shape);
}

void GetTrianglePointer(ImVec2 &a, ImVec2 &b, ImVec2 &c, ImVec2 targetPoint, float angle, float height)
{
    //// Simple Work around to have approximatively the tip on the target point
    //// TODO: Find better solution
    // if ( thickness > 0.0f )
    //	targetPoint += ImVec2( 0.0f, thickness * 0.5f );

    float cos2pi_3 = ImCos((2.0f / 3.0f) * IM_PI);
    float sin2pi_3 = ImSin((2.0f / 3.0f) * IM_PI);

    // minus to have the pointer turning in positive
    // PI/2 to have the triangle pointing up when angle == 0.0f
    float cos0 = ImCos(-angle - IM_PI * 0.5f);
    float sin0 = ImSin(-angle - IM_PI * 0.5f);

    // ImVec2 center = targetPoint + ImVec2( -1.0f, 0.0f );
    b = ImVec2(cos2pi_3 - 1.0f, sin2pi_3);
    c = ImVec2(cos2pi_3 - 1.0f, -sin2pi_3);

    a = targetPoint;
    b = ImRotate(b, cos0, sin0) * 2.0f * height / 3.0f + targetPoint;
    c = ImRotate(c, cos0, sin0) * 2.0f * height / 3.0f + targetPoint;
}

void DrawTriangleCursor(ImDrawList *pDrawList, ImVec2 targetPoint, float angle, float size, float thickness, ImU32 col)
{
    ImVec2 a, b, c;
    GetTrianglePointer(a, b, c, targetPoint, angle, size);

    pDrawList->AddTriangle(a, b, c, col, thickness);
}

void DrawTriangleCursorFilled(ImDrawList *pDrawList, ImVec2 targetPoint, float angle, float size, ImU32 col)
{
    ImVec2 a, b, c;
    GetTrianglePointer(a, b, c, targetPoint, angle, size);

    pDrawList->AddTriangleFilled(a, b, c, col);
}

void GetRotatePoints(ImVec2 *pts, int pts_count, ImVec2 pivot, float angle)
{
    float  cos0 = ImCos(angle);
    float  sin0 = ImSin(angle);
    ImVec2 t;
    for (int k = 0; k < pts_count; ++k)
    {
        t = pts[k] - pivot;
        ImVec2 r;
        r.x    = t.x * cos0 - t.y * sin0;
        r.y    = t.x * sin0 + t.y * cos0;
        pts[k] = r + pivot;
    }
}

void ImInternalGetSignetVertices(ImVec2 *pts, int pts_count, ImVec2 targetPoint, float width, float height,
                                 float height_ratio, float align01, float angle, float thickness)
{
    //// Simple Work around to have approximatively the tip on the target point
    //// TODO: Find better solution
    // if ( thickness > 0.0f )
    //	targetPoint += ImVec2( 0.0f, thickness * 0.5f );

    float left   = ImLerp(targetPoint.x - width, targetPoint.x, align01);
    float right  = left + width;
    float top    = ImLerp(targetPoint.y, targetPoint.y + height, height_ratio);
    float bottom = targetPoint.y + height;

    pts[0] = targetPoint;
    pts[1] = ImVec2(left, top);
    pts[2] = ImVec2(left, bottom);
    pts[3] = ImVec2(right, bottom);
    pts[4] = ImVec2(right, top);

    GetRotatePoints(&pts[0], pts_count, targetPoint, angle);
}

void DrawSignetCursor(ImDrawList *pDrawList, ImVec2 targetPoint, float width, float height, float height_ratio,
                      float align01, float angle, float thickness, ImU32 col)
{
    ImVec2 pts[5];
    ImInternalGetSignetVertices(&pts[0], 5, targetPoint, width, height, height_ratio, align01, angle, thickness);

    pDrawList->AddPolyline(&pts[0], 5, col, ImDrawFlags_Closed, thickness);
}

void DrawSignetFilledCursor(ImDrawList *pDrawList, ImVec2 targetPoint, float width, float height, float height_ratio,
                            float align01, float angle, ImU32 col)
{
    ImVec2 pts[5];
    ImInternalGetSignetVertices(&pts[0], 5, targetPoint, width, height, height_ratio, align01, angle, 0.0f);

    pDrawList->AddConvexPolyFilled(&pts[0], 5, col);
}

void DrawProceduralColor1DNearest(ImDrawList *pDrawList, ImWidgetsColor1DCallback func, void *pUserData, float minX,
                                  float maxX, ImVec2 position, ImVec2 size, int resolutionX)
{
    // ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

    float const sx = size.x / ((float)resolutionX);

    float const dx  = 1.0f / ((float)resolutionX);
    float const hdx = 0.5f / ((float)resolutionX);

    for (int i = 0; i < resolutionX; ++i)
    {
        float x0;
        float x1;
        (void)x1;
        x0 = ScaleFromNormalized(((float)i + 0) * dx + hdx, minX, maxX);

        ImU32 const col00 = func(x0, pUserData);
        pDrawList->AddRectFilledMultiColor(position + ImVec2(sx * (i + 0), 0.0f),
                                           position + ImVec2(sx * (i + 1), size.y), col00, col00, col00, col00);
    }
}

void DrawProceduralColor1DBilinear(ImDrawList *pDrawList, ImWidgetsColor1DCallback func, void *pUserData, float minX,
                                   float maxX, ImVec2 position, ImVec2 size, int resolutionX)
{
    // ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

    float const sx = size.x / ((float)resolutionX);

    float const dx = 1.0f / ((float)resolutionX);
    // float const hdx = 0.5f / ( ( float )resolutionX );

    for (int i = 0; i < resolutionX; ++i)
    {
        float x0;
        float x1;
        (void)x1;
        x0 = ScaleFromNormalized(((float)i + 0) * dx, minX, maxX);
        x1 = ScaleFromNormalized(((float)i + 1) * dx, minX, maxX);

        ImU32 const col00 = func(x0, pUserData);
        ImU32 const col01 = func(x0, pUserData);
        ImU32 const col10 = func(x1, pUserData);
        ImU32 const col11 = func(x1, pUserData);
        pDrawList->AddRectFilledMultiColor(position + ImVec2(sx * (i + 0), 0.0f),
                                           position + ImVec2(sx * (i + 1), size.y), col00, col10, col11, col01);
    }
}

void DrawProceduralColor2DNearest(ImDrawList *pDrawList, ImWidgetsColor2DCallback func, void *pUserData, float minX,
                                  float maxX, float minY, float maxY, ImVec2 position, ImVec2 size, int resolutionX,
                                  int resolutionY)
{
    // ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

    float const sx = size.x / ((float)resolutionX);
    float const sy = size.y / ((float)resolutionY);

    float const dy  = 1.0f / ((float)resolutionY);
    float const dx  = 1.0f / ((float)resolutionX);
    float const hdx = 0.5f / ((float)resolutionX);
    float const hdy = 0.5f / ((float)resolutionY);

    for (int i = 0; i < resolutionX; ++i)
    {
        float x0;
        float x1;
        (void)x1;
        x0 = ScaleFromNormalized(((float)i + 0) * dx + hdx, minX, maxX);

        for (int j = 0; j < resolutionY; ++j)
        {
            float y0;
            float y1;
            (void)y1;
            y0 = ScaleFromNormalized(((float)(j + 0) * dy + hdy), maxY, minY);

            ImU32 const col00 = func(x0, y0, pUserData);
            pDrawList->AddRectFilledMultiColor(position + ImVec2(sx * (i + 0), sy * (j + 0)),
                                               position + ImVec2(sx * (i + 1), sy * (j + 1)), col00, col00, col00,
                                               col00);
        }
    }
}

void DrawProceduralColor2DBilinear(ImDrawList *pDrawList, ImWidgetsColor2DCallback func, void *pUserData, float minX,
                                   float maxX, float minY, float maxY, ImVec2 position, ImVec2 size, int resolutionX,
                                   int resolutionY)
{
    // ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

    float const sx = size.x / ((float)resolutionX);
    float const sy = size.y / ((float)resolutionY);

    float const dy = 1.0f / ((float)resolutionY);
    float const dx = 1.0f / ((float)resolutionX);
    // float const hdx = 0.5f / ( ( float )resolutionX );
    // float const hdy = 0.5f / ( ( float )resolutionY );

    for (int i = 0; i < resolutionX; ++i)
    {
        float x0;
        float x1;
        (void)x1;
        x0 = ScaleFromNormalized(((float)i + 0) * dx, minX, maxX);
        x1 = ScaleFromNormalized(((float)i + 1) * dx, minX, maxX);

        for (int j = 0; j < resolutionY; ++j)
        {
            float y0;
            float y1;
            (void)y1;
            y0 = ScaleFromNormalized(((float)(j + 0) * dy), maxY, minY);
            y1 = ScaleFromNormalized(((float)(j + 1) * dy), maxY, minY);

            ImU32 const col00 = func(x0, y0, pUserData);
            ImU32 const col01 = func(x0, y1, pUserData);
            ImU32 const col10 = func(x1, y0, pUserData);
            ImU32 const col11 = func(x1, y1, pUserData);
            pDrawList->AddRectFilledMultiColor(position + ImVec2(sx * (i + 0), sy * (j + 0)),
                                               position + ImVec2(sx * (i + 1), sy * (j + 1)), col00, col10, col11,
                                               col01);
        }
    }
}

ImU32 ImInternalHueFunc(float ttt, void *pUserData)
{
    float alpha  = ((float *)pUserData)[0];
    float offset = ((float *)pUserData)[1];
    float gamma  = ((float *)pUserData)[2];
    float tt     = ImPow(ttt, gamma);
    float t;
    if (tt - offset < 0.0f)
        t = ImFmod(1.0f + (tt - offset), 1.0f);
    else
        t = ImFmod(tt - offset, 1.0f);

    float r, g, b;
    ImGui::ColorConvertHSVtoRGB(t, 1.0f, 1.0f, r, g, b);
    int const ur = static_cast<int>(255.0f * r);
    int const ug = static_cast<int>(255.0f * g);
    int const ub = static_cast<int>(255.0f * b);
    int const ua = static_cast<int>(255.0f * alpha);
    return IM_COL32(ur, ug, ub, ua);
};
void DrawHueBand(ImDrawList *pDrawList, ImVec2 const vpos, ImVec2 const size, int division, float alpha, float gamma,
                 float offset)
{
    float data[] = {alpha, offset, gamma};

    DrawProceduralColor1DBilinear(pDrawList, &ImInternalHueFunc, &data[0], 0.0f, 1.0f, vpos, size, division);
}

void DrawHueBand(ImDrawList *pDrawList, ImVec2 const vpos, ImVec2 const size, int division, float colorStartRGB[3],
                 float alpha, float gamma)
{
    float h, s, v;
    ImGui::ColorConvertRGBtoHSV(colorStartRGB[0], colorStartRGB[1], colorStartRGB[2], h, s, v);
    DrawHueBand(pDrawList, vpos, size, division, alpha, gamma, h);
}

ImU32 ImInternalLumianceFunc(float tt, void *pUserData)
{
    float h     = ((float *)pUserData)[0];
    float s     = ((float *)pUserData)[1];
    float v     = ((float *)pUserData)[2];
    float gamma = ((float *)pUserData)[3];
    float t     = ImPow(tt, gamma);
    float r, g, b;
    ImGui::ColorConvertHSVtoRGB(h, s, ImLerp(0.0f, v, t), r, g, b);
    int const ur = static_cast<int>(255.0f * r);
    int const ug = static_cast<int>(255.0f * g);
    int const ub = static_cast<int>(255.0f * b);
    return IM_COL32(ur, ug, ub, 255);
}
void DrawLumianceBand(ImDrawList *pDrawList, ImVec2 const vpos, ImVec2 const size, int division, ImVec4 const &color,
                      float gamma)
{
    float h, s, v;
    ImGui::ColorConvertRGBtoHSV(color.x, color.y, color.z, h, s, v);
    float data[] = {h, s, v, gamma};
    DrawProceduralColor1DBilinear(pDrawList, &ImInternalLumianceFunc, &data[0], 0.0f, 1.0f, vpos, size, division);
}

ImU32 ImInternalSaturationFunc(float tt, void *pUserData)
{
    float h     = ((float *)pUserData)[0];
    float s     = ((float *)pUserData)[1];
    float v     = ((float *)pUserData)[2];
    float gamma = ((float *)pUserData)[3];
    float t     = ImPow(tt, gamma);
    float r, g, b;
    ImGui::ColorConvertHSVtoRGB(h, ImLerp(0.0f, 1.0f, t) * s, ImLerp(0.5f, 1.0f, t) * v, r, g, b);
    int const ur = static_cast<int>(255.0f * r);
    int const ug = static_cast<int>(255.0f * g);
    int const ub = static_cast<int>(255.0f * b);
    return IM_COL32(ur, ug, ub, 255);
}
void DrawSaturationBand(ImDrawList *pDrawList, ImVec2 const vpos, ImVec2 const size, int division, ImVec4 const &color,
                        float gamma)
{
    float h, s, v;
    ImGui::ColorConvertRGBtoHSV(color.x, color.y, color.z, h, s, v);
    float data[] = {h, s, v, gamma};

    DrawProceduralColor1DBilinear(pDrawList, &ImInternalSaturationFunc, &data[0], 0.0f, 1.0f, vpos, size, division);
}

void DrawColorRing(ImDrawList *pDrawList, ImVec2 const curPos, ImVec2 const size, float thickness_,
                   ImWidgetsColor1DCallback func, void *pUserData, int division, float colorOffset, bool bIsBilinear)
{
    float const radius = ImMin(size.x, size.y) * 0.5f;

    float const dAngle = 2.0f * IM_PI / ((float)division);
    float       angle  = 2.0f * IM_PI / 3.0f;

    ImVec2 offset = curPos + ImVec2(radius, radius);
    if (size.x < size.y)
    {
        offset.y += 0.5f * (size.y - size.x);
    }
    else if (size.x > size.y)
    {
        offset.x += 0.5f * (size.x - size.y);
    }

    float const thickness = ImSaturate(thickness_) * radius;

    ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();
    pDrawList->PrimReserve(division * 6, division * 4);
    for (int i = 0; i < division; ++i)
    {
        float x0 = radius * ImCos(angle);
        float y0 = radius * ImSin(angle);

        float x1 = radius * ImCos(angle + dAngle);
        float y1 = radius * ImSin(angle + dAngle);

        float x2 = (radius - thickness) * ImCos(angle + dAngle);
        float y2 = (radius - thickness) * ImSin(angle + dAngle);

        float x3 = (radius - thickness) * ImCos(angle);
        float y3 = (radius - thickness) * ImSin(angle);

        pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx));
        pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + 1));
        pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + 2));

        pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx));
        pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + 2));
        pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + 3));

        float const t0    = fmodf(colorOffset + ((float)i) / ((float)division), 1.0f);
        ImU32 const uCol0 = func(t0, pUserData);

        float const t1    = fmodf(colorOffset + ((float)(i + 1)) / ((float)division), 1.0f);
        ImU32 const uCol1 = bIsBilinear ? func(t1, pUserData) : uCol0;
        pDrawList->PrimWriteVtx(offset + ImVec2(x0, y0), uv, uCol0);
        pDrawList->PrimWriteVtx(offset + ImVec2(x1, y1), uv, uCol1);
        pDrawList->PrimWriteVtx(offset + ImVec2(x2, y2), uv, uCol1);
        pDrawList->PrimWriteVtx(offset + ImVec2(x3, y3), uv, uCol0);
        angle += dAngle;
    }
}

ImU32 ImColor2DCallbackOkLab(float a, float b, void *pUserData)
{
    float *pL = (float *)pUserData;
    float  L  = *pL;

    float rr, gg, bb;
    ColorConvertOKLABtoRGB(rr, gg, bb, L, a, b);

    return ImGui::GetColorU32(ImVec4(rr, gg, bb, 1.0f));
}
ImU32 ImColor2DCallbackOkLch(float x, float y, void *pUserData)
{
    float *pL = (float *)pUserData;
    float  L  = *pL;

    float angle = ImAtan2(y, x);
    float r     = ImSqrt(x * x + y * y);

    if (angle < 0.0f)
        angle += 2.0f * IM_PI;

    float c = r;
    float h = angle / (2.0f * IM_PI);

    float rr, gg, bb;
    ColorConvertOKLCHtosRGB(rr, gg, bb, L, c, h);

    return ImGui::GetColorU32(ImVec4(rr, gg, bb, 1.0f));
}

void DrawOkLabQuad(ImDrawList *pDrawList, ImVec2 start, ImVec2 size, float L, int resX, int resY)
{
    DrawProceduralColor2DBilinear(pDrawList, &ImColor2DCallbackOkLab, &L, 0.0f, 1.0f, 0.0f, 1.0f, start, size, resX,
                                  resY);
}
void DrawOkLchQuad(ImDrawList *pDrawList, ImVec2 start, ImVec2 size, float L, int resX, int resY)
{
    DrawProceduralColor2DBilinear(pDrawList, &ImColor2DCallbackOkLch, &L, -1.0f, 1.0f, -1.0f, 1.0f, start, size, resX,
                                  resY);
}

// Adapted version from:
// cf. https://github.com/ocornut/imgui/issues/760#issuecomment-237195662
// Remove C++ feature, work with float instead of double, no auto
// Far from efficient, perf depending no the size, but it work!
void DrawShapeWithHole(ImDrawList *draw, ImVec2 *poly, int points_count, ImU32 color, ImRect *p_bb, int gap,
                       int strokeWidth)
{
    ImVector<ImVec2> scanHits;
    ImVec2           min, max; // polygon min/max points
    ImGuiIO          io = ImGui::GetIO();
    float            y;
    bool             isMinMaxDone = false;

    // find the orthagonal bounding box
    // probably can put this as a predefined
    if (!isMinMaxDone)
    {
        min.x = min.y = FLT_MAX;
        max.x = max.y = FLT_MIN;
        // for ( auto p : poly )
        for (int i = 0; i < points_count; ++i)
        {
            ImVec2 p = poly[i];
            if (p.x < min.x)
                min.x = p.x;
            if (p.y < min.y)
                min.y = p.y;
            if (p.x > max.x)
                max.x = p.x;
            if (p.y > max.y)
                max.y = p.y;
        }
        isMinMaxDone = true;
    }
    ImRect bb;
    if (p_bb == NULL)
    {
        bb.Min = min;
        bb.Max = max;
    }
    else
    {
        bb = *p_bb;
    }

    // Bounds check
    if ((max.x < 0) || (min.x > io.DisplaySize.x) || (max.y < 0) || (min.y > io.DisplaySize.y))
        return;

    // Vertically clip
    if (min.y <= 0)
        min.y = 0;
    if (max.y > io.DisplaySize.y)
        max.y = io.DisplaySize.y;

    // so we know we start on the outside of the object we step out by 1.
    min.x -= 1;
    max.x += 1;

    // Initialise our starting conditions
    y = min.y;

    struct ImVec2CompX
    {
        static int IMGUI_CDECL Comp(const void *lhs, const void *rhs)
        {
            if (((const ImVec2 *)lhs)->x > ((const ImVec2 *)rhs)->x)
                return +1;
            if (((const ImVec2 *)lhs)->x < ((const ImVec2 *)rhs)->x)
                return -1;
            return 0;
        }
    };

    draw->PushClipRect(bb.Min, bb.Max, true);
    // Go through each scan line iteratively, jumping by 'gap' pixels each time
    while (y < max.y)
    {
        scanHits.clear();
        {
            int    jump = 1;
            ImVec2 fp   = poly[0];

            for (int i = 0; i < points_count - 1; i++)
            {
                ImVec2 pa = poly[i];
                ImVec2 pb = poly[i + 1];

                // jump double/dud points
                if (pa.x == pb.x && pa.y == pb.y)
                    continue;

                // if we encounter our hull/poly start point, then we've now created the
                // closed
                // hull, jump the next segment and reset the first-point
                if ((!jump) && (fp.x == pb.x) && (fp.y == pb.y))
                {
                    if (i < points_count - 2)
                    {
                        fp   = poly[i + 2];
                        jump = 1;
                        i++;
                    }
                }
                else
                {
                    jump = 0;
                }

                // test to see if this segment makes the scan-cut.
                if ((pa.y > pb.y && y < pa.y && y > pb.y) || (pa.y < pb.y && y > pa.y && y < pb.y))
                {
                    ImVec2 intersect;

                    intersect.y = y;
                    if (pa.x == pb.x)
                    {
                        intersect.x = pa.x;
                    }
                    else
                    {
                        intersect.x = (pb.x - pa.x) / (pb.y - pa.y) * (y - pa.y) + pa.x;
                    }
                    scanHits.push_back(intersect);
                }
            }

            // Sort the scan hits by X, so we have a proper left->right ordering
            ImQsort(&scanHits[0], scanHits.size(), sizeof(ImVec2), &ImVec2CompX::Comp);

            // generate the line segments.
            {
                int i = 0;
                int l = scanHits.size() - 1; // we need pairs of points, this prevents segfault.
                for (i = 0; i < l; i += 2) { draw->AddLine(scanHits[i], scanHits[i + 1], color, (float)strokeWidth); }
            }
        }
        y += gap;
    } // for each scan line
    draw->PopClipRect();

    scanHits.clear();
}

// void DrawImageConvexShape( ImDrawList* draw, ImTextureID img, ImVec2* poly, int points_count, ImU32 tint,
// 						   ImVec2 uv_offset, ImVec2 uv_scale )
// {
// 	if ( points_count < 3 || ( tint & IM_COL32_A_MASK ) == 0 )
// 		return;

// 	ImRect bb;
// 	bb.Min = ImVec2(  FLT_MAX,  FLT_MAX );
// 	bb.Max = ImVec2( -FLT_MAX, -FLT_MAX );
// 	for ( ImVec2* v = poly; v < poly + points_count; ++v )
// 	{
// 		bb.Min.x = ImMin( bb.Min.x, v->x );
// 		bb.Min.y = ImMin( bb.Min.y, v->y );
// 		bb.Max.x = ImMax( bb.Max.x, v->x );
// 		bb.Max.y = ImMax( bb.Max.y, v->y );
// 	}

// 	// TODO add flag to support ImDrawListFlags_AntiAliasedFill
// 	// cf. AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
// 	{
// 		const bool push_texture_id = img != draw->_CmdHeader.TextureId;
// 		if ( push_texture_id )
// 			draw->PushTextureID( img );
// 		const int idx_count = ( points_count - 2 ) * 3;
// 		const int vtx_count = points_count;
// 		draw->PrimReserve( idx_count, vtx_count );
// 		for ( int i = 0; i < vtx_count; i++ )
// 		{
// 			draw->_VtxWritePtr->pos = poly[ i ];
// 			ImVec2 uv;
// 			uv.x = ImRescale( poly[ i ].x, bb.Min.x, bb.Max.x, 0.0f, 1.0f ) * uv_scale.x + uv_offset.x;
// 			uv.y = ImRescale( poly[ i ].y, bb.Min.y, bb.Max.y, 0.0f, 1.0f ) * uv_scale.y + uv_offset.y;
// 			draw->_VtxWritePtr->uv = uv;
// 			draw->_VtxWritePtr->col = tint;
// 			draw->_VtxWritePtr++;
// 		}
// 		for ( int i = 2; i < points_count; i++ )
// 		{
// 			draw->_IdxWritePtr[ 0 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx );
// 			draw->_IdxWritePtr[ 1 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + i - 1 );
// 			draw->_IdxWritePtr[ 2 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + i );
// 			draw->_IdxWritePtr += 3;
// 		}
// 		draw->_VtxCurrentIdx += ( ImDrawIdx )vtx_count;
// 		if ( push_texture_id )
// 			draw->PopTextureID();
// 	}
// }

// void DrawImageConcaveShape( ImDrawList* draw, ImTextureID img, ImVec2* poly, int points_count, ImU32 tint,
// 						   ImVec2 uv_offset, ImVec2 uv_scale )
// {
// 	if ( points_count < 3 || ( tint & IM_COL32_A_MASK ) == 0 )
// 		return;

// 	ImRect bb;
// 	bb.Min = ImVec2(  FLT_MAX,  FLT_MAX );
// 	bb.Max = ImVec2( -FLT_MAX, -FLT_MAX );
// 	for ( ImVec2* v = poly; v < poly + points_count; ++v )
// 	{
// 		bb.Min.x = ImMin( bb.Min.x, v->x );
// 		bb.Min.y = ImMin( bb.Min.y, v->y );
// 		bb.Max.x = ImMax( bb.Max.x, v->x );
// 		bb.Max.y = ImMax( bb.Max.y, v->y );
// 	}

// 	ImTriangulator0 triangulator;
// 	unsigned int triangle[ 3 ];
// 	// TODO add flag to support ImDrawListFlags_AntiAliasedFill
// 	// cf. AddConcavePolyFilled(const ImVec2* points, const int points_count, ImU32 col)
// 	{
// 		const bool push_texture_id = img != draw->_CmdHeader.TextureId;
// 		if ( push_texture_id )
// 			draw->PushTextureID( img );
// 		const int idx_count = ( points_count - 2 ) * 3;
// 		const int vtx_count = points_count;
// 		draw->PrimReserve( idx_count, vtx_count );
// 		for ( int i = 0; i < vtx_count; i++ )
// 		{
// 			draw->_VtxWritePtr[ 0 ].pos = poly[ i ];
// 			ImVec2 uv;
// 			uv.x = ImRescale( poly[ i ].x, bb.Min.x, bb.Max.x, 0.0f, 1.0f ) * uv_scale.x + uv_offset.x;
// 			uv.y = ImRescale( poly[ i ].y, bb.Min.y, bb.Max.y, 0.0f, 1.0f ) * uv_scale.y + uv_offset.y;
// 			draw->_VtxWritePtr[ 0 ].uv = uv;
// 			draw->_VtxWritePtr[ 0 ].col = tint;
// 			draw->_VtxWritePtr++;
// 		}
// 		draw->_Data->TempBuffer.reserve_discard( ( ImTriangulator0::EstimateScratchBufferSize( points_count ) + sizeof(
// ImVec2 ) ) / sizeof( ImVec2 ) ); 		triangulator.Init( poly, points_count, draw->_Data->TempBuffer.Data );
// while ( triangulator._TrianglesLeft > 0 )
// 		{
// 			triangulator.GetNextTriangle( triangle );
// 			draw->_IdxWritePtr[ 0 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + triangle[ 0 ] );
// 			draw->_IdxWritePtr[ 1 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + triangle[ 1 ] );
// 			draw->_IdxWritePtr[ 2 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + triangle[ 2 ] );
// 			draw->_IdxWritePtr += 3;
// 		}
// 		draw->_VtxCurrentIdx += ( ImDrawIdx )vtx_count;
// 		if ( push_texture_id )
// 			draw->PopTextureID();
// 	}
// }

#ifdef IM_SUPPORT_CUSTOM_SHADER
void CreateInternalShader(ImDrawShader *shaders_out, char const *shader_name, int sizeof_vs_const_buffer,
                          void *vs_const_buffer, int sizeof_ps_const_buffer, void *ps_const_buffer)
{
#ifndef IM_SUPPORT_CUSTOM_SHADER
    IM_ASSERT(false && "Custom Shader not available on this platform");

    shaders_out = NULL;

    return;
#endif

    IM_ASSERT(shaders_out != NULL);

#define FILENAME_BUF 128
    char filename_ps[FILENAME_BUF];
    char filename_vs[FILENAME_BUF];

#ifdef IM_GFX_HLSL
    ImFormatString(filename_vs, FILENAME_BUF, "./shaders/%s/%s.%s", "hlsl_src", shader_name, "hlsl");
    ImFormatString(filename_ps, FILENAME_BUF, "./shaders/%s/%s.%s", "hlsl_src", shader_name, "hlsl");
#elif defined(IM_GFX_GLSL)
    ImFormatString(filename_vs, FILENAME_BUF, "./shaders/%s/%s_vs.%s", "glsl", shader_name, "glsl");
    ImFormatString(filename_ps, FILENAME_BUF, "./shaders/%s/%s_ps.%s", "glsl", shader_name, "glsl");
#elif defined(IM_GFX_MSL)
    ImFormatString(filename_vs, FILENAME_BUF, "./shaders/%s/%s_vs.%s", "msl", shader_name, "msl");
    ImFormatString(filename_ps, FILENAME_BUF, "./shaders/%s/%s_ps.%s", "msl", shader_name, "msl");
#elif defined(IM_GFX_WGPU)
    ImFormatString(filename_vs, FILENAME_BUF, "./shaders/%s/%s_vs.%s", "wgpu", shader_name, "wgpu");
    ImFormatString(filename_ps, FILENAME_BUF, "./shaders/%s/%s_ps.%s", "wgpu", shader_name, "wgpu");
#endif

    char  *vs_source;
    char  *ps_source;
    size_t file_data_size_vs;
    size_t file_data_size_ps;
    LoadShaderFile(&file_data_size_vs, &vs_source, filename_vs);
    LoadShaderFile(&file_data_size_ps, &ps_source, filename_ps);

    IM_ASSERT(vs_source && ps_source);
    IM_ASSERT(file_data_size_vs != 0 && file_data_size_ps != 0);

    ImDrawShader shader = ImPlatform::CreateShader(vs_source, ps_source, sizeof_vs_const_buffer, vs_const_buffer,
                                                   sizeof_ps_const_buffer, ps_const_buffer);

    memcpy(shaders_out, &shader, sizeof(ImDrawShader));

    IM_FREE(vs_source);
    IM_FREE(ps_source);
}

void DrawMarker(ImDrawList *pDrawList, ImVec2 start, ImVec2 size, ImU32 fg_color, ImU32 bg_color, float rot_angle_rad,
                float shape_size, float linewidth, float antialiasing, ImWidgetsMarker marker,
                ImWidgetsDrawType draw_type)
{
    IM_ASSERT((PlatformData.features & ImWidgetsFeatures_Markers) != 0);

    ImWidgetsMarkerBuffer params;
    params.fg_color     = ImGui::ColorConvertU32ToFloat4(fg_color);
    params.bg_color     = ImGui::ColorConvertU32ToFloat4(bg_color);
    params.rotation     = ImVec2(ImCos(rot_angle_rad), ImSin(rot_angle_rad));
    params.linewidth    = linewidth;
    params.size         = shape_size;
    params.type         = (float)marker;
    params.antialiasing = antialiasing;
    params.draw_type    = (float)draw_type;
    params.pad0         = 0.0f;
    if (memcmp(&params, gs_pContext->markerShader.cpu_ps_data, sizeof(ImWidgetsMarkerBuffer)))
    {
        ImPlatform::UpdateCustomPixelShaderConstants(gs_pContext->markerShader, &params);
    }
    ImPlatform::BeginCustomShader(pDrawList, gs_pContext->markerShader);
    ImRect bb(start, start + size);
    pDrawList->AddImageQuad((ImTextureID)gs_pContext->whiteImg, bb.GetBL(), bb.GetBR(), bb.GetTR(), bb.GetTL(),
                            ImVec2(0, 0), ImVec2(1, 0), ImVec2(1, 1), ImVec2(0, 1), IM_COL32(255, 255, 255, 255));
    ImPlatform::EndCustomShader(pDrawList);
}
#endif

#include "common.h"

//////////////////////////////////////////////////////////////////////////
// Widgets
//////////////////////////////////////////////////////////////////////////
void DrawChromaticityPlot(ImDrawList *pDrawList, ImVec2 curPos, ImVec2 size, ImVec2 primR, ImVec2 primG, ImVec2 primB,
                          ImVec2 whitePoint, float *xyzToRGB, int chromeLineSamplesCount, int resX, int resY,
                          ImU32 maskColor, float wavelengthMin, float wavelengthMax, ImVec2 plotMin, ImVec2 plotMax,
                          ImVec2 gridMin, ImVec2 gridMax, bool showColorSpaceTriangle, bool showWhitePoint,
                          bool showBorder, bool showGrid, ImU32 borderColor, float borderThickness, ImU32 gridColor, float gridThickness)
{
    ImVec2 sq_min = ImVec2(curPos.x + ImRescale(gridMin.x, plotMin.x, plotMax.x, 0.0f, size.x),
                           curPos.y + ImRescale(gridMin.y, plotMin.y, plotMax.y, size.y, 0.0f));
    ImVec2 sq_max = ImVec2(curPos.x + ImRescale(gridMax.x, plotMin.x, plotMax.x, 0.0f, size.x),
                           curPos.y + ImRescale(gridMax.y, plotMin.y, plotMax.y, size.y, 0.0f));

    ImRect clipRect(curPos, curPos + size);
    pDrawList->PushClipRect(clipRect.Min, clipRect.Max, true);

    DrawProceduralColor2DBilinear(
        pDrawList,
        [](float x, float y, void *pUserData)
        {
            float *pXYZ2RGB = ((float *)pUserData);
            return ImColorFrom_xyz(x, y, 1.0f - x - y, pXYZ2RGB, 1.0f / 2.2f);
        },
        xyzToRGB, gridMin.x, gridMax.x, gridMax.y, gridMin.y, sq_min, sq_max - sq_min, resX, resY);

	float            illum;
	float            x, y, z;
	float            sum;
	ImVector<ImVec2> chromLine;
	// +1 to close the line
	// +5 for the enclosure
	int ptsCount = chromeLineSamplesCount + 1 + 5;
	chromLine.resize(ptsCount);

	// Compute chromaticity line
	for (int i = 0; i < chromeLineSamplesCount; ++i)
	{
		float const wavelength =
			ScaleFromNormalized(((float)i) / ((float)(chromeLineSamplesCount - 1)), wavelengthMin, wavelengthMax);

		illum = ImFunctionFromData(wavelength, s_Illuminance_D65_min, s_Illuminance_D65_max, s_Illuminance_D65,
								   s_Illuminance_D65_samplesCount);
		x     = illum * ImFunctionFromData(wavelength, s_CIE_1931_2deg_min, s_CIE_1931_2deg_max, s_CIE_1931_2deg_X,
										   s_CIE_1931_2deg_samplesCount);
		y     = illum * ImFunctionFromData(wavelength, s_CIE_1931_2deg_min, s_CIE_1931_2deg_max, s_CIE_1931_2deg_Y,
										   s_CIE_1931_2deg_samplesCount);
		z     = illum * ImFunctionFromData(wavelength, s_CIE_1931_2deg_min, s_CIE_1931_2deg_max, s_CIE_1931_2deg_Z,
										   s_CIE_1931_2deg_samplesCount);

		sum = x + y + z;

		x /= sum;
		y /= sum;

		chromLine[i] = ImVec2(x, y);
	}
	chromLine[chromeLineSamplesCount] = chromLine[0];
	// plotMin.x, plotMax.x, plotMin.y, plotMax.y
	chromLine[chromeLineSamplesCount + 1] = ImVec2(plotMax.x, plotMax.y);
	chromLine[chromeLineSamplesCount + 2] = ImVec2(plotMax.x, plotMin.y);
	chromLine[chromeLineSamplesCount + 3] = ImVec2(plotMin.x, plotMin.y);
	chromLine[chromeLineSamplesCount + 4] = ImVec2(plotMin.x, plotMax.y);
	chromLine[chromeLineSamplesCount + 5] = ImVec2(plotMax.x, plotMax.y);

	// Rescale to screen coordinates
	for (int i = 0; i < ptsCount; ++i)
	{
		chromLine[i].x = Rescale(chromLine[i].x, plotMin.x, plotMax.x, curPos.x, curPos.x + size.x);
		chromLine[i].y = Rescale(chromLine[i].y, plotMin.y, plotMax.y, curPos.y + size.y, curPos.y - 1.0f);
	}

	// Calculate number of tick marks at 10 nm intervals
	int tickCount = (int)ImFloor((wavelengthMax - wavelengthMin) / 10.0f) + 1;
	ImVector<ImVec4> tickMarks;
	tickMarks.resize(tickCount); // Stores tick mark location and orientation

	float firstTick = (ImFloor(wavelengthMin / 10.f) + 1.f) * 10.f;
	for (int tickIdx = 0; tickIdx < tickCount; ++tickIdx)
	{
		float nm = firstTick + tickIdx * 10.0f;
		// spdlog::info("Tick {}: Wavelength = {}", tickIdx, nm);
		float t    = (nm - wavelengthMin) / (wavelengthMax - wavelengthMin);
		float fIdx = t * (chromeLineSamplesCount - 1);
		int i0 = ImClamp((int)ImFloor(fIdx), 0, chromeLineSamplesCount - 2);
		int i1 = i0 + 1;
		float frac = fIdx - (float)i0;

		// Interpolate position between chromLine[i0] and chromLine[i1]
		ImVec2 pos = ImLerp(chromLine[i0], chromLine[i1], frac);

		// Compute tangent direction between i0 and i1
		ImVec2 tangent = ImNormalized(chromLine[i1] - chromLine[i0]);
		ImVec2 normal(-tangent.y, tangent.x);
		normal = ImNormalized(normal); // Ensure normal is unit length

		tickMarks[tickIdx] = ImVec4(pos.x, pos.y, normal.x, normal.y);
	}

    // Workaround: Overdraw with strokeWidth of 2. Because we seem to have missing the first and last row of pixel.
    //			The problem is more visible with alpha < 255.
    DrawShapeWithHole(pDrawList, &chromLine[0], ptsCount, maskColor, &clipRect, 1, 2);

    if (showGrid)
    {
        const float tick_len = 8.0f;

        // Draw square
        pDrawList->AddRect(sq_min, sq_max, gridColor, 0.0f, 0, gridThickness);

        // Draw grid lines (vertical and horizontal) at 0.1 increments within gridMin/gridMax
        auto gridColorHalf = ImGui::GetColorU32(gridColor, 0.5f);

        // X grid lines (vertical)
        int t_start_i = (int)ImCeil((gridMin.x + 1e-5f) * 10.0f);
        int t_end_i   = (int)ImFloor((gridMax.x - 1e-5f) * 10.0f);
        for (int ti = t_start_i; ti <= t_end_i; ++ti)
        {
            float t = ti * 0.1f;
            float x = ImLerp(sq_min.x, sq_max.x, (t - gridMin.x) / (gridMax.x - gridMin.x));
            pDrawList->AddLine(ImVec2(x, sq_min.y), ImVec2(x, sq_max.y), gridColorHalf, 0.5f*gridThickness);

            // Bottom edge (tick inside)
            {
                float y0 = sq_max.y;
                float y1 = y0 + tick_len;
                pDrawList->AddLine(ImVec2(x, y0), ImVec2(x, y1), gridColor, 0.75f*gridThickness);
            }
            // Top edge (tick inside)
            {
                float y0 = sq_min.y;
                float y1 = y0 - tick_len;
                pDrawList->AddLine(ImVec2(x, y0), ImVec2(x, y1), gridColor, 0.75f*gridThickness);
            }
        }
        // Y grid lines (horizontal)
        t_start_i = (int)ImCeil((gridMin.y + 1e-5f) * 10.0f);
        t_end_i   = (int)ImFloor((gridMax.y - 1e-5f) * 10.0f);
        for (int ti = t_start_i; ti <= t_end_i; ++ti)
        {
            float t = ti * 0.1f;
            float y = ImLerp(sq_min.y, sq_max.y, (t - gridMin.y) / (gridMax.y - gridMin.y));
            pDrawList->AddLine(ImVec2(sq_min.x, y), ImVec2(sq_max.x, y), gridColorHalf, 0.5f*gridThickness);

            // Left edge (tick inside)
            {
                float x0 = sq_min.x;
                float x1 = x0 + tick_len;
                pDrawList->AddLine(ImVec2(x0, y), ImVec2(x1, y), gridColor, 0.75f*gridThickness);
            }
            // Right edge (tick inside)
            {
                float x0 = sq_max.x;
                float x1 = x0 - tick_len;
                pDrawList->AddLine(ImVec2(x0, y), ImVec2(x1, y), gridColor, 0.75f*gridThickness);
            }
        }
    }

    if (showBorder)
    {
        pDrawList->AddPolyline(&chromLine[0], chromeLineSamplesCount, borderColor, ImDrawFlags_Closed, borderThickness);
		
		ImGui::PushFont(nullptr, 10.f);
		// Draw tick marks stored in tickMarks
		const float tick_length = 4.0f;
		const float major_tick_length = 8.0f;
		for (int i = 0; i < tickMarks.size(); ++i)
		{
			ImVec4 tick = tickMarks[i];
			ImVec2 p(tick.x, tick.y);
			ImVec2 normal(tick.z, tick.w);

			// Compute wavelength for this tick
			float nm = firstTick + i * 10.0f;
			// Check if tick is at a 100 nm multiple
			bool is_major = (static_cast<int>(nm) % 100 == 0);

			// Already rescaled to screen coordinates above
			// Draw tick mark perpendicular to the curve
			ImVec2 tick_start = p;
			ImVec2 tick_end   = p + normal * (is_major ? major_tick_length : tick_length);

			pDrawList->AddLine(tick_start, tick_end, borderColor, is_major ? borderThickness : borderThickness * 0.5f);

			// Add text label for major ticks (100 nm multiples)
			if (is_major)
			{
				static char label[8];
				ImFormatString(label, sizeof(label), "%d nm", static_cast<int>(nm));

				// Compute text size
				ImVec2 text_size = ImGui::CalcTextSize(label);

				// Offset text slightly along the normal direction from the tick end
				const float text_offset = text_size.y;
				ImVec2 text_pos = tick_end + normal * text_offset;

				// Align text position continuously based on normal direction using ImLerp
				text_pos += ImLerp(-text_size, ImVec2(0.f, 0.f), 0.5f * (normal.x + 1.0f));

				pDrawList->AddText(text_pos, IM_COL32(0,0,0,255), label);
				pDrawList->AddText(text_pos - ImVec2{1.f,1.f}, IM_COL32(255,255,255,255), label);
			}
		}
		ImGui::PopFont();
    }

    const float radius = 1.5f * borderThickness;
	ImVec2 sRGBLines[] = {primR, primG, primB};

	if (showColorSpaceTriangle)
	{
		for (int i = 0; i < 3; ++i)
		{
			ImVec2 &vCur = sRGBLines[i];
			vCur.x       = curPos.x + ImRescale(vCur.x, plotMin.x, plotMax.x, 0.0f, size.x);
			vCur.y       = curPos.y + ImRescale(vCur.y, plotMin.y, plotMax.y, size.y, 0.0f);
		}
		pDrawList->AddPolyline(&sRGBLines[0], 3, IM_COL32(255, 255, 255, 255), ImDrawFlags_Closed, borderThickness);
	}

	if (showGrid)
	{
		ImVec2 mouse_pos = ImGui::GetIO().MousePos;
		if (clipRect.Contains(mouse_pos))
		{
			// Convert mouse position to chromaticity coordinates
			float x = ImClamp((mouse_pos.x - curPos.x) / size.x, 0.0f, 1.0f);
			float y = ImClamp((mouse_pos.y - curPos.y) / size.y, 0.0f, 1.0f);

			// Rescale to chromaticity coordinates
			float chrom_x = plotMin.x + x * (plotMax.x - plotMin.x);
			float chrom_y = plotMax.y - y * (plotMax.y - plotMin.y);

			// Convert chromaticity coordinates back to screen
			float screen_x = curPos.x + ImRescale(chrom_x, plotMin.x, plotMax.x, 0.0f, size.x);
			float screen_y = curPos.y + ImRescale(chrom_y, plotMin.y, plotMax.y, size.y, 0.0f);

			// Draw vertical and horizontal lines
			pDrawList->AddLine(ImVec2(screen_x, sq_min.y), ImVec2(screen_x, sq_max.y), IM_COL32(0, 0, 0, 128), 1.5f);
			pDrawList->AddLine(ImVec2(sq_min.x, screen_y), ImVec2(sq_max.x, screen_y), IM_COL32(0, 0, 0, 128), 1.5f);

			// Format text for coordinates
			char label_x[32], label_y[32];
			ImFormatString(label_x, sizeof(label_x), "x = %.3f", chrom_x);
			ImFormatString(label_y, sizeof(label_y), "y = %.3f", chrom_y);

			ImVec2 text_size = ImGui::CalcTextSize(label_x);

			// Draw text near lines, but keep inside plot area
			float pad = 4.f;
			float center_x = (sq_min.x + sq_max.x) * 0.5f;
			float center_y = (sq_min.y + sq_max.y) * 0.5f;

			// For x label: position left/right depending on screen_x, above/below depending on screen_y
			bool x_right = (screen_x > center_x);
			bool y_above = (screen_y < center_y);

			ImVec2 text_x_pos = ImVec2(
				x_right ? screen_x - pad - text_size.x : screen_x + pad,
				y_above ? sq_max.y - pad + text_size.y : sq_min.y - pad - text_size.y
			);

			// For y label: align horizontally opposite to x label, vertically near screen_y
			ImVec2 text_y_pos = ImVec2(
				x_right ? sq_min.x + 2.5f * pad : sq_max.x - pad - text_size.x,
				y_above ? screen_y + pad : screen_y - pad - text_size.y
			);

			pDrawList->AddText(text_x_pos, IM_COL32(0,0,0,255), label_x);
			pDrawList->AddText(text_x_pos - ImVec2{1.f,1.f}, IM_COL32(255,255,255,255), label_x);

			pDrawList->AddText(text_y_pos, IM_COL32(0,0,0,255), label_y);
			pDrawList->AddText(text_y_pos - ImVec2{1.f,1.f}, IM_COL32(255,255,255,255), label_y);
		}
	}

	if (showColorSpaceTriangle)
	{

		// Draw filled circles at triangle corners, colored by primary
		pDrawList->AddCircleFilled(sRGBLines[0], radius, IM_COL32(200, 0, 0, 255), 0); // Red
		pDrawList->AddCircleFilled(sRGBLines[1], radius, IM_COL32(0, 200, 0, 255), 0); // Green
		pDrawList->AddCircleFilled(sRGBLines[2], radius, IM_COL32(0, 0, 200, 255), 0); // Blue

        pDrawList->AddCircle(sRGBLines[0], radius + 1.f, IM_COL32(0, 0, 0, 255), 0, 1.5f); // Red
        pDrawList->AddCircle(sRGBLines[1], radius + 1.f, IM_COL32(0, 0, 0, 255), 0, 1.5f); // Green
        pDrawList->AddCircle(sRGBLines[2], radius + 1.f, IM_COL32(0, 0, 0, 255), 0, 1.5f); // Blue

		// Draw text labels for R, G, B
		const char* labels[3] = {"R", "G", "B"};
		for (int i = 0; i < 3; ++i)
		{
			ImVec2 label_pos = sRGBLines[i] + ImVec2(radius + 2.0f, -radius - 8.0f);
			pDrawList->AddText(label_pos, IM_COL32(0,0,0,255), labels[i]);
			pDrawList->AddText(label_pos-ImVec2{1.f,1.f}, IM_COL32(255,255,255,255), labels[i]);
		}
	}

	if (showWhitePoint)
	{
		ImVec2 vWhitePoint = whitePoint;
		vWhitePoint.x      = curPos.x + ImRescale(vWhitePoint.x, plotMin.x, plotMax.x, 0.0f, size.x);
		vWhitePoint.y      = curPos.y + ImRescale(vWhitePoint.y, plotMin.y, plotMax.y, size.y, 0.0f);
		pDrawList->AddCircleFilled(vWhitePoint, radius, IM_COL32(255, 255, 255, 255), 0);
		pDrawList->AddCircle(vWhitePoint, radius + 1.f, IM_COL32(0, 0, 0, 255), 0, 1.5f);

		// Draw text label for W
		ImVec2 label_pos = vWhitePoint + ImVec2(radius + 2.0f, -radius - 8.0f);
		pDrawList->AddText(label_pos, IM_COL32(0,0,0,255), "W");
		pDrawList->AddText(label_pos-ImVec2{1.f,1.f}, IM_COL32(255,255,255,255), "W");
	}

    pDrawList->PopClipRect();
}

bool ChromaticityPlotDragBehavior(const char *str_id, ImVec2 curPos, ImVec2 size, ImVec2 *primR, ImVec2 *primG,
                                  ImVec2 *primB, ImVec2 *whitePoint, ImVec2 plotMin, ImVec2 plotMax)
{
    // Detect click/drag inside the plot area
    ImGui::InvisibleButton(str_id, size);
    if (ImGui::IsItemActive() && ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        ImVec2 mouse_pos = ImGui::GetIO().MousePos;
        ImVec2 plot_pos  = mouse_pos - curPos;

        // Convert from screen to chromaticity coordinates
        ImVec2 rel = plot_pos / size;

        ImVec2 clicked;
        clicked.x = plotMin.x + rel.x * (plotMax.x - plotMin.x);
        // Flip the y coordinate so dragging matches the plot orientation
        clicked.y = plotMax.y - rel.y * (plotMax.y - plotMin.y);

        // Clamp to plot region
        clicked = ImClamp(clicked, plotMin, plotMax);

        // Find which chromaticity (red, green, blue, white) is closest to the clicked point
        // You need to provide access to the chromaticity points (primR, primG, primB, whitePoint)
        ImVec2 chromas[4]  = {*primR, *primG, *primB, *whitePoint};
        int    closest_idx = 0;
        float  min_dist    = FLT_MAX;
        for (int i = 0; i < 4; ++i)
        {
			ImVec2 d = chromas[i] - clicked;
            float dist = ImLengthSqr(d);
            if (dist < min_dist)
            {
                min_dist    = dist;
                closest_idx = i;
            }
        }

        // Update the closest chromaticity
        switch (closest_idx)
        {
        case 0: *primR = clicked; break;
        case 1: *primG = clicked; break;
        case 2: *primB = clicked; break;
        case 3: *whitePoint = clicked; break;
        }
        return true;
    }

    return false;
}

void DrawChromaticityPointsGeneric(ImDrawList *pDrawList, ImVec2 curPos, ImVec2 size, float *rgbToXYZ,
                                   float *colors4, // AoS: rgba, rgba, ...
                                   int color_count, float minX, float maxX, float minY, float maxY, ImU32 plotColor,
                                   float radius, int num_segments, int colorStride)
{
    ImRect clipRect(curPos, curPos + size);
    pDrawList->PushClipRect(clipRect.Min, clipRect.Max, true);
    float *current = colors4;
    for (int i = 0; i < color_count; ++i)
    {
        float x, y, z;
        Mat33RowMajorMulVec3(x, y, z, rgbToXYZ, current);
        float sum = x + y + z;
        x /= sum;
        y /= sum;
        ImVec2 vCur;
        vCur.x = curPos.x + ImRescale(x, minX, maxX, 0.0f, size.x);
        vCur.y = curPos.y + ImRescale(y, minY, maxY, size.y, 0.0f);
        pDrawList->AddCircleFilled(vCur, radius, plotColor, num_segments);
        current += colorStride;
    }
    pDrawList->PopClipRect();
}

void DrawChromaticityPoints(ImDrawList *pDrawList, ImVec2 curPos, ImVec2 size, ImU32 *colors, int color_count,
                            float minX, float maxX, float minY, float maxY, ImU32 plotColor, float radius,
                            int num_segments)
{
    ImVector<float> colorsConverted;
    ImU32ColorToImRGBColor(colorsConverted, colors, color_count);
    DrawChromaticityPointsGeneric(pDrawList, curPos, size, s_ColorSpace_RGB2XYZ_sRGB, &colorsConverted[0], color_count,
                                  minX, maxX, minY, maxY, plotColor, radius, num_segments, 3);
}

// #pragma optimize( "", off )
void DrawChromaticityLinesGeneric(ImDrawList *pDrawList, ImVec2 curPos, ImVec2 size, float *rgbToXYZ,
                                  float *colors4, // AoS
                                  int color_count, float minX, float maxX, float minY, float maxY, ImU32 plotColor,
                                  ImDrawFlags flags, float thickness, int colorStride)
{
    ImRect clipRect(curPos, curPos + size);
    pDrawList->PushClipRect(clipRect.Min, clipRect.Max, true);
    ImVector<ImVec2> lines;
    lines.resize(color_count);
    float *current = colors4;
    for (int k = 0; k < color_count; ++k)
    {
        float x, y, z;
        Mat33RowMajorMulVec3(x, y, z, rgbToXYZ, current);

        float sum = x + y + z;
        x /= sum;
        y /= sum;

        ImVec2 vCur;

        vCur.x = curPos.x + ImRescale(x, minX, maxX, 0.0f, size.x);
        vCur.y = curPos.y + ImRescale(y, minY, maxY, size.y, 0.0f);

        lines[k] = vCur;

        current += colorStride;
    }

    pDrawList->AddPolyline(&lines[0], color_count, plotColor, flags, thickness);
    pDrawList->PopClipRect();
}

void DrawChromaticityLines(ImDrawList *pDrawList, ImVec2 curPos, ImVec2 size, ImU32 *colors, int color_count,
                           float minX, float maxX, float minY, float maxY, ImU32 plotColor, ImDrawFlags flags,
                           float thickness)
{
    ImVector<float> colorsConverted;
    ImU32ColorToImRGBColor(colorsConverted, colors, color_count);
    DrawChromaticityLinesGeneric(pDrawList, curPos, size, s_ColorSpace_RGB2XYZ_sRGB, &colorsConverted[0], color_count,
                                 minX, maxX, minY, maxY, plotColor, flags, thickness, 3);
}

void DrawLinearLineGraduation(ImDrawList *drawlist, ImVec2 start, ImVec2 end, float mainLineThickness, ImU32 mainCol,
                              int division0, float height0, float thickness0, float angle0, ImU32 col0, int division1,
                              float height1, float thickness1, float angle1, ImU32 col1, int division2, float height2,
                              float thickness2, float angle2, ImU32 col2)
{
    if (mainLineThickness < 0.5f || (thickness0 < 0.5f && thickness1 < 0.5f && thickness2 < 0.5f))
        return;
    if ((mainCol & IM_COL32_A_MASK) == 0 && ((col0 | col1 | col2) & IM_COL32_A_MASK) == 0)
        return;

    ImVec2 delta   = end - start;
    float  length  = ImLength(delta);
    ImVec2 forward = ImNormalized(delta);
    ImVec2 up      = ImAntiHalfTurn(forward);
    if (division0 > 0)
    {
        // float dx0 = length / ( ( float )division0 );
        float  inv_div0 = 1.0f / ((float)division0);
        ImVec2 up0;
        if (angle0 != 0.0f)
        {
            float cos0 = ImCos(-angle0);
            float sin0 = ImSin(-angle0);
            up0        = ImRotate(up, cos0, sin0);
        }
        else
        {
            up0 = up;
        }
        for (int k = 0; k <= division0; ++k)
        {
            float  fk = (float)k;
            float  t  = fk * inv_div0;
            ImVec2 v  = ImLerp(start, end, t);
            drawlist->AddLine(v, v + up0 * height0, col0, thickness0);
        }
    }
    if (division0 > 0 && division1 > 0)
    {
        float dx0      = length / ((float)division0);
        float inv_div0 = 1.0f / ((float)division0);
        float dx1      = dx0 / ((float)division1);
        // float inv_div1 = 1.0f / ( ( float )division1 );
        ImVec2 up1;
        if (angle1 != 0.0f)
        {
            float cos0 = ImCos(-angle1);
            float sin0 = ImSin(-angle1);
            up1        = ImRotate(up, cos0, sin0);
        }
        else
        {
            up1 = up;
        }
        for (int p = 0; p < division0; ++p)
        {
            float  fp = (float)p;
            float  t0 = fp * inv_div0;
            ImVec2 v0 = ImLerp(start, end, t0);
            for (int k = 1; k < division1; ++k)
            {
                float fk = (float)k;
                // float t1 = fk * inv_div1;
                ImVec2 v = v0 + forward * (fk * dx1);
                drawlist->AddLine(v, v + up1 * height1, col1, thickness1);
            }
        }
    }
    if (division0 > 0 && division1 > 0 && division2 > 0)
    {
        float dx0      = length / ((float)division0);
        float inv_div0 = 1.0f / ((float)division0);
        float dx1      = dx0 / ((float)division1);
        // float inv_div1 = 1.0f / ( ( float )division1 );
        float dx2 = dx1 / ((float)division2);
        // float inv_div2 = 1.0f / ( ( float )division2 );
        ImVec2 up2;
        if (angle2 != 0.0f)
        {
            float cos0 = ImCos(-angle2);
            float sin0 = ImSin(-angle2);
            up2        = ImRotate(up, cos0, sin0);
        }
        else
        {
            up2 = up;
        }
        for (int p = 0; p < division0; ++p)
        {
            float  fp = (float)p;
            float  t0 = fp * inv_div0;
            ImVec2 v0 = ImLerp(start, end, t0);
            for (int q = 0; q < division1; ++q)
            {
                float  fk = (float)q;
                ImVec2 v1 = v0 + forward * (fk * dx1);
                for (int k = 1; k < division2; ++k)
                {
                    float  fk = (float)k;
                    ImVec2 v  = v1 + forward * (fk * dx2);
                    drawlist->AddLine(v, v + up2 * height2, col2, thickness2);
                }
            }
        }
    }
    drawlist->AddLine(start, end, mainCol, mainLineThickness);
}

void DrawLinearCircularGraduation(ImDrawList *drawlist, ImVec2 center, float radius, float start_angle, float end_angle,
                                  int num_segments, float mainLineThickness, ImU32 mainCol, int division0,
                                  float height0, float thickness0, float angle0, ImU32 col0, int division1,
                                  float height1, float thickness1, float angle1, ImU32 col1, int division2,
                                  float height2, float thickness2, float angle2, ImU32 col2)
{
    if (radius < 0.5f || (thickness0 < 0.5f && thickness1 < 0.5f && thickness2 < 0.5f))
        return;
    if ((mainCol & IM_COL32_A_MASK) == 0 && ((col0 | col1 | col2) & IM_COL32_A_MASK) == 0)
        return;

    if (start_angle > end_angle)
    {
        while (start_angle > end_angle) { start_angle += 2.0f * IM_PI; }
    }
    float angle_spread = end_angle - start_angle;
    // ImVec2 up = ImRotate( ImVec2( 1.0f, 0.0f ), ImCos( start_angle ), ImSin( start_angle ) );
    if (division0 > 0)
    {
        float da0 = angle_spread / ((float)division0);
        for (int k = 0; k <= division0; ++k)
        {
            float  fk    = (float)k;
            float  a0    = start_angle + fk * da0;
            float  a1    = a0 + angle0;
            float  cos00 = ImCos(-a0);
            float  sin00 = ImSin(-a0);
            float  cos01 = ImCos(-a1);
            float  sin01 = ImSin(-a1);
            ImVec2 up0   = ImRotate(ImVec2(1.0f, 0.0f), cos00, sin00);
            ImVec2 up1   = ImRotate(ImVec2(1.0f, 0.0f), cos01, sin01);
            ImVec2 v     = center + up0 * radius;
            drawlist->AddLine(v, v + up1 * height0, col0, thickness0);
        }
    }
    if (division0 > 0 && division1 > 0)
    {
        float da0 = angle_spread / ((float)division0);
        float da1 = da0 / ((float)division1);
        for (int p = 0; p < division0; ++p)
        {
            float fp = (float)p;
            float ap = start_angle + fp * da0;
            for (int k = 1; k < division1; ++k)
            {
                float  fk    = (float)k;
                float  a0    = ap + fk * da1;
                float  a1    = a0 + angle1;
                float  cos00 = ImCos(-a0);
                float  sin00 = ImSin(-a0);
                float  cos01 = ImCos(-a1);
                float  sin01 = ImSin(-a1);
                ImVec2 up0   = ImRotate(ImVec2(1.0f, 0.0f), cos00, sin00);
                ImVec2 up1   = ImRotate(ImVec2(1.0f, 0.0f), cos01, sin01);
                ImVec2 v     = center + up0 * radius;
                drawlist->AddLine(v, v + up1 * height1, col1, thickness1);
            }
        }
    }
    if (division0 > 0 && division1 > 0 && division2 > 0)
    {
        float da0 = angle_spread / ((float)division0);
        float da1 = da0 / ((float)division1);
        float da2 = da1 / ((float)division2);
        for (int p = 0; p < division0; ++p)
        {
            float fp = (float)p;
            float ap = start_angle + fp * da0;
            for (int q = 0; q < division1; ++q)
            {
                float fq = (float)q;
                float aq = ap + fq * da1;
                for (int k = 1; k < division2; ++k)
                {
                    float  fk    = (float)k;
                    float  a0    = aq + fk * da2;
                    float  a1    = a0 + angle2;
                    float  cos00 = ImCos(-a0);
                    float  sin00 = ImSin(-a0);
                    float  cos01 = ImCos(-a1);
                    float  sin01 = ImSin(-a1);
                    ImVec2 up0   = ImRotate(ImVec2(1.0f, 0.0f), cos00, sin00);
                    ImVec2 up1   = ImRotate(ImVec2(1.0f, 0.0f), cos01, sin01);
                    ImVec2 v     = center + up0 * radius;
                    drawlist->AddLine(v, v + up1 * height2, col2, thickness2);
                }
            }
        }
    }

    drawlist->PathArcTo(center, radius, -start_angle, -end_angle, num_segments);
    drawlist->PathStroke(mainCol, ImDrawFlags_None, mainLineThickness);
}

void DrawLogLineGraduation(ImDrawList *drawlist, ImVec2 start, ImVec2 end, float mainLineThickness, ImU32 mainCol,
                           int division0, float height0, float thickness0, float angle0, ImU32 col0, int division1,
                           float height1, float thickness1, float angle1, ImU32 col1)
{
    if (mainLineThickness < 0.5f || (thickness0 < 0.5f && thickness1 < 0.5f))
        return;
    if ((mainCol & IM_COL32_A_MASK) == 0 && ((col0 | col1) & IM_COL32_A_MASK) == 0)
        return;

    ImVec2 delta   = end - start;
    float  length  = ImLength(delta);
    ImVec2 forward = ImNormalized(delta);
    ImVec2 up      = ImAntiHalfTurn(forward);
    if (division0 > 0)
    {
        // float dx0 = length / ( ( float )division0 );
        float  inv_div0 = 1.0f / ((float)division0);
        ImVec2 up0;
        if (angle0 != 0.0f)
        {
            float cos0 = ImCos(-angle0);
            float sin0 = ImSin(-angle0);
            up0        = ImRotate(up, cos0, sin0);
        }
        else
        {
            up0 = up;
        }
        for (int k = 0; k <= division0; ++k)
        {
            float  fk = (float)k;
            float  t  = fk * inv_div0;
            ImVec2 v  = ImLerp(start, end, t);
            drawlist->AddLine(v, v + up0 * height0, col0, thickness0);
        }
    }
    if (division0 > 0 && division1 > 0)
    {
        float dx0      = length / ((float)division0);
        float inv_div0 = 1.0f / ((float)division0);
        // float dx1 = dx0 / ( ( float )division1 );
        // float inv_div1 = 1.0f / ( ( float )division1 );
        float  scale = 1.0f / ImLog((float)(division1 + 1));
        ImVec2 up1;
        if (angle1 != 0.0f)
        {
            float cos0 = ImCos(-angle1);
            float sin0 = ImSin(-angle1);
            up1        = ImRotate(up, cos0, sin0);
        }
        else
        {
            up1 = up;
        }
        for (int p = 0; p < division0; ++p)
        {
            float  fp = (float)p;
            float  t0 = fp * inv_div0;
            ImVec2 v0 = ImLerp(start, end, t0);
            for (int k = 2; k < division1 + 1; ++k)
            {
                float  fk = ImLog((float)(k)) * scale;
                ImVec2 v  = v0 + forward * (fk * dx0);
                drawlist->AddLine(v, v + up1 * height1, col1, thickness1);
            }
        }
    }

    drawlist->AddLine(start, end, mainCol, mainLineThickness);
}

void DrawLogCircularGraduation(ImDrawList *drawlist, ImVec2 center, float radius, float start_angle, float end_angle,
                               int num_segments, float mainLineThickness, ImU32 mainCol, int division0, float height0,
                               float thickness0, float angle0, ImU32 col0, int division1, float height1,
                               float thickness1, float angle1, ImU32 col1)
{
    if (radius < 0.5f || (thickness0 < 0.5f && thickness1 < 0.5f))
        return;
    if ((mainCol & IM_COL32_A_MASK) == 0 && ((col0 | col1) & IM_COL32_A_MASK) == 0)
        return;

    if (start_angle > end_angle)
    {
        while (start_angle > end_angle) { start_angle += 2.0f * IM_PI; }
    }
    float angle_spread = end_angle - start_angle;
    // ImVec2 up = ImRotate( ImVec2( 1.0f, 0.0f ), ImCos( start_angle ), ImSin( start_angle ) );
    if (division0 > 0)
    {
        float da0 = angle_spread / ((float)division0);
        for (int k = 0; k <= division0; ++k)
        {
            float  fk    = (float)k;
            float  a0    = start_angle + fk * da0;
            float  a1    = a0 + angle0;
            float  cos00 = ImCos(-a0);
            float  sin00 = ImSin(-a0);
            float  cos01 = ImCos(-a1);
            float  sin01 = ImSin(-a1);
            ImVec2 up0   = ImRotate(ImVec2(1.0f, 0.0f), cos00, sin00);
            ImVec2 up1   = ImRotate(ImVec2(1.0f, 0.0f), cos01, sin01);
            ImVec2 v     = center + up0 * radius;
            drawlist->AddLine(v, v + up1 * height0, col0, thickness0);
        }
    }
    if (division0 > 0 && division1 > 0)
    {
        float da0 = angle_spread / ((float)division0);
        // float da1 = da0 / ( ( float )division1 );
        float scale = 1.0f / ImLog((float)(division1 + 1));
        for (int p = 0; p < division0; ++p)
        {
            float fp = (float)p;
            float ap = start_angle + fp * da0;

            for (int k = 2; k < division1 + 1; ++k)
            {
                float fk = ImLog((float)(k)) * scale;
                float a0 = ap + fk * da0;

                float  a1    = a0 + angle1;
                float  cos00 = ImCos(-a0);
                float  sin00 = ImSin(-a0);
                float  cos01 = ImCos(-a1);
                float  sin01 = ImSin(-a1);
                ImVec2 up0   = ImRotate(ImVec2(1.0f, 0.0f), cos00, sin00);
                ImVec2 up1   = ImRotate(ImVec2(1.0f, 0.0f), cos01, sin01);
                ImVec2 v     = center + up0 * radius;
                drawlist->AddLine(v, v + up1 * height1, col1, thickness1);
            }
        }
    }

    drawlist->PathArcTo(center, radius, -start_angle, -end_angle, num_segments);
    drawlist->PathStroke(mainCol, ImDrawFlags_None, mainLineThickness);
}

void Im_CircleFromRect(ImRect r, void *data)
{
    ImCircle *c = (ImCircle *)data;
    c->center   = r.GetCenter();
    c->radius   = ImMin(r.GetWidth(), r.GetHeight()) * 0.5f;
}
void Im_CapsuleHFromRect(ImRect r, void *data)
{
    ImCapsule *c           = (ImCapsule *)data;
    float      half_height = r.GetHeight() * 0.5f;
    c->pos                 = r.Min + ImVec2(half_height, half_height);
    c->length              = r.GetWidth() - 2.0f * half_height;
    c->thickness           = half_height;
}
void Im_CapsuleVFromRect(ImRect r, void *data)
{
    ImCapsule *c          = (ImCapsule *)data;
    float      half_width = r.GetWidth() * 0.5f;
    c->pos                = r.Min + ImVec2(half_width, half_width);
    c->length             = r.GetHeight() - 2.0f * half_width;
    c->thickness          = half_width;
}

bool Im_IsCircleContains(ImVec2 p, void *data)
{
    ImCircle *value = (ImCircle *)data;

    ImVec2 dx = value->center - p;

    return ImDot(dx, dx) < value->radius * value->radius;
}
bool Im_IsCapsuleHContains(ImVec2 p, void *data)
{
    ImCapsule *value = (ImCapsule *)data;

    // SDF From Inigo Quilez: https://iquilezles.org/articles/distfunctions2d/
    // "Rounded Exact Line"
    ImVec2 a = value->pos;
    ImVec2 b = {a.x + value->length, a.y};

    ImVec2 pa = p - a;
    ImVec2 ba = b - a;
    float  h  = ImClamp(ImDot(pa, ba) / ImDot(ba, ba), 0.0f, 1.0f);

    return (ImLength(pa - ba * h) - value->thickness) < 0.0f;
}
bool Im_IsCapsuleVContains(ImVec2 p, void *data)
{
    ImCapsule *value = (ImCapsule *)data;

    // SDF From Inigo Quilez: https://iquilezles.org/articles/distfunctions2d/
    // "Rounded Exact Line"
    ImVec2 a = value->pos;
    ImVec2 b = {a.x, a.y + value->length};

    ImVec2 pa = p - a;
    ImVec2 ba = b - a;
    float  h  = ImClamp(ImDot(pa, ba) / ImDot(ba, ba), 0.0f, 1.0f);

    return (ImLength(pa - ba * h) - value->thickness) < 0.0f;
}

bool Im_IsPolyConvexContains(ImVec2 p, void *data)
{
    ImPolyShapeData *value     = (ImPolyShapeData *)data;
    ImVec2          *pts       = value->pts;
    int              pts_count = value->pts_count;

    IM_ASSERT(pts_count >= 3);

    for (int k = 2; k < pts_count; ++k)
    {
        ImVec2 a = pts[0];
        ImVec2 b = pts[k - 1];
        ImVec2 c = pts[k];
        if (ImTriangleContainsPoint(a, b, c, p))
            return true;
    }

    return false;
}

bool Im_IsPolyConcaveContains(ImVec2 p, void *data)
{
    ImPolyShapeData *value     = (ImPolyShapeData *)data;
    ImVec2          *pts       = value->pts;
    int              pts_count = value->pts_count;

    IM_ASSERT(pts_count >= 3);

    ImRect bb;
    bb.Min = ImVec2(FLT_MAX, FLT_MAX);
    bb.Max = ImVec2(-FLT_MAX, -FLT_MAX);
    for (int k = 0; k < pts_count; ++k)
    {
        bb.Min.x = ImMin(bb.Min.x, pts[k].x);
        bb.Min.y = ImMin(bb.Min.y, pts[k].y);
        bb.Max.x = ImMax(bb.Max.x, pts[k].x);
        bb.Max.y = ImMax(bb.Max.y, pts[k].y);
    }
    if (!bb.ContainsWithPad(p, ImVec2(1.0f, 1.0f)))
        return false;

    ImDrawListSharedData *_Data = ImGui::GetCurrentWindow()->DrawList->_Data;

    ImTriangulator0 triangulator;
    unsigned int    triangle[3];
    {
        // Non Anti-aliased Fill
        // const int idx_count = ( pts_count - 2 ) * 3;
        triangulator.Init(pts, pts_count, _Data->TempBuffer.Data);
        while (triangulator._TrianglesLeft > 0)
        {
            triangulator.GetNextTriangle(triangle);
            if (ImTriangleContainsPoint(pts[triangle[0]], pts[triangle[1]], pts[triangle[2]], p))
                return true;
        }
    }

    return false;
}

bool Im_IsPolyWithHoleContains(ImVec2 p, void *data)
{
    ImPolyHoleShapeData *value       = (ImPolyHoleShapeData *)data;
    ImVec2              *pts         = value->pts;
    int                  pts_count   = value->pts_count;
    ImRect              *p_bb        = value->p_bb;
    int                  gap         = value->gap;
    int                  strokeWidth = value->strokeWidth;

    ImVector<ImVec2> scanHits;
    ImVec2           min, max; // polygon min/max points
    float            y;
    bool             isMinMaxDone = false;

    // find the orthagonal bounding box
    // probably can put this as a predefined
    if (!isMinMaxDone)
    {
        min.x = min.y = FLT_MAX;
        max.x = max.y = FLT_MIN;
        // for ( auto p : poly )
        for (int i = 0; i < pts_count; ++i)
        {
            ImVec2 p = pts[i];
            if (p.x < min.x)
                min.x = p.x;
            if (p.y < min.y)
                min.y = p.y;
            if (p.x > max.x)
                max.x = p.x;
            if (p.y > max.y)
                max.y = p.y;
        }
        isMinMaxDone = true;
    }
    ImRect bb;
    if (p_bb == NULL)
    {
        bb.Min = min;
        bb.Max = max;
    }
    else
    {
        bb = *p_bb;
    }
    if (!bb.ContainsWithPad(p, ImVec2(1.0f, 1.0f)))
        return false;

    // Bounds check
    if ((max.x < 0) || (max.y < 0))
        return false;

    // Vertically clip
    if (min.y <= 0)
        min.y = 0;

    // so we know we start on the outside of the object we step out by 1.
    min.x -= 1;
    max.x += 1;

    // Initialise our starting conditions
    y = min.y;

    struct ImVec2CompX
    {
        static int IMGUI_CDECL Comp(const void *lhs, const void *rhs)
        {
            if (((const ImVec2 *)lhs)->x > ((const ImVec2 *)rhs)->x)
                return +1;
            if (((const ImVec2 *)lhs)->x < ((const ImVec2 *)rhs)->x)
                return -1;
            return 0;
        }
    };

    while (y < max.y)
    {
        scanHits.clear();
        {
            int    jump = 1;
            ImVec2 fp   = pts[0];

            for (int i = 0; i < pts_count - 1; i++)
            {
                ImVec2 pa = pts[i];
                ImVec2 pb = pts[i + 1];

                // jump double/dud points
                if (pa.x == pb.x && pa.y == pb.y)
                    continue;

                // if we encounter our hull/poly start point, then we've now created the
                // closed
                // hull, jump the next segment and reset the first-point
                if ((!jump) && (fp.x == pb.x) && (fp.y == pb.y))
                {
                    if (i < pts_count - 2)
                    {
                        fp   = pts[i + 2];
                        jump = 1;
                        i++;
                    }
                }
                else
                {
                    jump = 0;
                }

                // test to see if this segment makes the scan-cut.
                if ((pa.y > pb.y && y < pa.y && y > pb.y) || (pa.y < pb.y && y > pa.y && y < pb.y))
                {
                    ImVec2 intersect;

                    intersect.y = y;
                    if (pa.x == pb.x)
                    {
                        intersect.x = pa.x;
                    }
                    else
                    {
                        intersect.x = (pb.x - pa.x) / (pb.y - pa.y) * (y - pa.y) + pa.x;
                    }
                    scanHits.push_back(intersect);
                }
            }

            // Sort the scan hits by X, so we have a proper left->right ordering
            ImQsort(&scanHits[0], scanHits.size(), sizeof(ImVec2), &ImVec2CompX::Comp);

            // generate the line segments.
            int i = 0;
            int l = scanHits.size() - 1; // we need pairs of points, this prevents segfault.
            for (i = 0; i < l; i += 2)
            {
                ImVec2 a = scanHits[i];
                ImVec2 b = scanHits[i + 1];
                if (ImRect(a, b).ContainsWithPad(p, ImVec2(0.0f, (float)strokeWidth)))
                {
                    scanHits.clear();
                    return true;
                }
            }
        }
        y += gap;
    }

    return false;
}

void Im_InlineOffsetCircle(void *data, ImVec2 offset)
{
    ImCircle *values = (ImCircle *)data;
    values->center += offset;
}
void Im_InlineOffsetCapsuleH(void *data, ImVec2 offset)
{
    ImCapsule *values = (ImCapsule *)data;
    values->pos += offset;
}
void Im_InlineOffsetCapsuleV(void *data, ImVec2 offset)
{
    ImCapsule *values = (ImCapsule *)data;
    values->pos += offset;
}
void Im_InlineOffsetConvex(void *data, ImVec2 offset)
{
    ImPolyShapeData *values    = (ImPolyShapeData *)data;
    int              pts_count = values->pts_count;
    for (int k = 0; k < pts_count; ++k) { values->pts[k] += offset; }
}
void Im_InlineOffsetConcave(void *data, ImVec2 offset)
{
    ImPolyShapeData *values    = (ImPolyShapeData *)data;
    int              pts_count = values->pts_count;
    for (int k = 0; k < pts_count; ++k) { values->pts[k] += offset; }
}
void Im_InlineOffsetWithHole(void *data, ImVec2 offset)
{
    ImPolyHoleShapeData *values    = (ImPolyHoleShapeData *)data;
    int                  pts_count = values->pts_count;
    for (int k = 0; k < pts_count; ++k) { values->pts[k] += offset; }
}

void Im_DrawCircle(ImDrawList *drawlist, ImU32 col, float thickness, void *data)
{
    ImCircle *values = (ImCircle *)data;
    drawlist->AddCircle(values->center, values->radius, col, 0, thickness);
}
void Im_DrawCapsuleH(ImDrawList *drawlist, ImU32 col, float thickness, void *data)
{
    ImCapsule *values = (ImCapsule *)data;
    // drawlist->PathArcToFast( values->pos, values->thickness, 9, 3 );
    // drawlist->PathArcToFast( values->pos + ImVec2( values->length, 0.0f ), values->thickness, 3, -3 );
    // drawlist->PathStroke( col );
    ImVec2 t = {values->thickness, values->thickness};
    drawlist->AddRect(values->pos - t, values->pos + t + ImVec2(values->length, 0.0f), col, values->thickness,
                      ImDrawFlags_RoundCornersAll);
}
void Im_DrawCapsuleV(ImDrawList *drawlist, ImU32 col, float thickness, void *data)
{
    ImCapsule *values = (ImCapsule *)data;
    // drawlist->PathArcToFast( values->pos, values->thickness, 0, -6 );
    // drawlist->PathArcToFast( values->pos + ImVec2( 0.0f, values->length ), values->thickness, 6, 0 );
    // drawlist->PathStroke( col );
    ImVec2 t = {values->thickness, values->thickness};
    drawlist->AddRect(values->pos - t, values->pos + t + ImVec2(0.0f, values->length), col, values->thickness,
                      ImDrawFlags_RoundCornersAll);
}
void Im_DrawShapeConvex(ImDrawList *drawlist, ImU32 col, float thickness, void *data)
{
    ImPolyShapeData *values = (ImPolyShapeData *)data;
    drawlist->AddPolyline(values->pts, values->pts_count, col, 0, thickness);
}
void Im_DrawShapeConcave(ImDrawList *drawlist, ImU32 col, float thickness, void *data)
{
    ImPolyShapeData *values = (ImPolyShapeData *)data;
    drawlist->AddPolyline(values->pts, values->pts_count, col, 0, thickness);
}
// TODO
void Im_DrawShapeWithHole(ImDrawList *drawlist, ImU32 col, float thickness, void *data)
{
    ImPolyHoleShapeData *values = (ImPolyHoleShapeData *)data;
    drawlist->AddPolyline(values->pts, values->pts_count, col, 0, thickness);
}

void Im_DrawCircleFilled(ImDrawList *drawlist, ImU32 col, void *data)
{
    ImCircle *values = (ImCircle *)data;
    drawlist->AddCircleFilled(values->center, values->radius, col, 0);
}
void Im_DrawCircleFilledTex(ImDrawList *drawlist, ImU32 col, void *data, ImTextureID tex, ImVec2 uv_min, ImVec2 uv_max)
{
    ImCircle *values = (ImCircle *)data;
    // int vert_start_idx = drawlist->VtxBuffer.Size;
    ImVec2 min = values->center - ImVec2(values->radius, values->radius);
    ImVec2 max = values->center + ImVec2(values->radius, values->radius);
    drawlist->AddImageRounded(tex, min, max, uv_min, uv_max, col, values->radius, ImDrawFlags_RoundCornersAll);
    // int vert_end_idx = drawlist->VtxBuffer.Size;
    // ImGui::ShadeVertsLinearUV( drawlist, vert_start_idx, vert_end_idx, min, max, uv_min, uv_max, true );
}
void Im_DrawCapsuleHFilled(ImDrawList *drawlist, ImU32 col, void *data)
{
    ImCapsule *values = (ImCapsule *)data;
    // drawlist->PathArcToFast( values->pos, values->thickness, 9, 3 );
    // drawlist->PathArcToFast( values->pos + ImVec2( values->length, 0.0f ), values->thickness, 3, -3 );
    // drawlist->PathFillConvex( col );
    ImVec2 t = {values->thickness, values->thickness};
    drawlist->AddRectFilled(values->pos - t, values->pos + t + ImVec2(values->length, 0.0f), col, values->thickness,
                            ImDrawFlags_RoundCornersAll);
}
void Im_DrawCapsuleHFilledTex(ImDrawList *drawlist, ImU32 col, void *data, ImTextureID tex, ImVec2 uv_min,
                              ImVec2 uv_max)
{
    // const bool push_texture_id = tex != drawlist->_CmdHeader.TextureId;
    // if ( push_texture_id )
    //	drawlist->PushTextureID( tex );

    ImCapsule *values = (ImCapsule *)data;

    ImVec2 t = {values->thickness, values->thickness};
    // drawlist->AddRectFilled( values->pos - t, values->pos + t + ImVec2( values->length, 0.0f ), col,
    // values->thickness, ImDrawFlags_RoundCornersAll );
    drawlist->AddImageRounded(tex, values->pos - t, values->pos + t + ImVec2(values->length, 0.0f), uv_min, uv_max, col,
                              values->thickness, ImDrawFlags_RoundCornersAll);
    // drawlist->AddImage( tex, values->pos - t, values->pos + t + ImVec2( values->length, 0.0f ), { 0.0f, 0.0f },
    // { 1.0f, 1.0f }, col );

    // int vert_start_idx = drawlist->VtxBuffer.Size;
    // drawlist->PathArcToFast( values->pos, values->thickness, 9, 3 );
    // drawlist->PathArcToFast( values->pos + ImVec2( values->length, 0.0f ), values->thickness, 3, -3 );
    // drawlist->PathFillConvex( col );
    // int vert_end_idx = drawlist->VtxBuffer.Size;
    // ImVec2 t = { values->thickness, values->thickness };
    // ImGui::ShadeVertsLinearUV(
    //	drawlist,
    //	vert_start_idx, vert_end_idx,
    //	values->pos - t, values->pos + t + ImVec2( values->length, 0.0f ),
    //	{ 0.0f, 0.0f }, { 1.0f, 1.0f },
    //	true );

    // if ( push_texture_id )
    //	drawlist->PopTextureID();
}
void Im_DrawCapsuleVFilled(ImDrawList *drawlist, ImU32 col, void *data)
{
    ImCapsule *values = (ImCapsule *)data;
    // drawlist->PathArcToFast( values->pos, values->thickness, 0, -6 );
    // drawlist->PathArcToFast( values->pos + ImVec2( 0.0f, values->length ), values->thickness, 6, 0 );
    // drawlist->PathFillConvex( col );
    ImVec2 t = {values->thickness, values->thickness};
    drawlist->AddRectFilled(values->pos - t, values->pos + t + ImVec2(0.0f, values->length), col, values->thickness,
                            ImDrawFlags_RoundCornersAll);
}
void Im_DrawCapsuleVFilledTex(ImDrawList *drawlist, ImU32 col, void *data, ImTextureID tex, ImVec2 uv_min,
                              ImVec2 uv_max)
{
    ImCapsule *values = (ImCapsule *)data;
    drawlist->PathArcToFast(values->pos, values->thickness, 0, -6);
    drawlist->PathArcToFast(values->pos + ImVec2(0.0f, values->length), values->thickness, 6, 0);
    // DrawImageConvexShape( drawlist, tex, drawlist->_Path.Data, drawlist->_Path.Size, col,
    // 					  uv_min, uv_max );
    drawlist->_Path.Size = 0;
}
void Im_DrawShapeConvexFilled(ImDrawList *drawlist, ImU32 col, void *data)
{
    ImPolyShapeData *values = (ImPolyShapeData *)data;
    drawlist->AddConvexPolyFilled(values->pts, values->pts_count, col);
}
void Im_DrawShapeConvexFilledTex(ImDrawList *drawlist, ImU32 col, void *data, ImTextureID tex, ImVec2 uv_min,
                                 ImVec2 uv_max)
{
    // ImPolyShapeData* values = ( ImPolyShapeData* )data;
    // DrawImageConvexShape( drawlist, tex, values->pts, values->pts_count, col,
    // 					  uv_min, uv_max );
}
void Im_DrawShapeConcaveFilled(ImDrawList *drawlist, ImU32 col, void *data)
{
    ImPolyShapeData *values = (ImPolyShapeData *)data;
    drawlist->AddConcavePolyFilled(values->pts, values->pts_count, col);
}
void Im_DrawShapeConcaveFilledTex(ImDrawList *drawlist, ImU32 col, void *data, ImTextureID tex, ImVec2 uv_min,
                                  ImVec2 uv_max)
{
    // ImPolyShapeData* values = ( ImPolyShapeData* )data;
    // DrawImageConcaveShape( drawlist, tex, values->pts, values->pts_count, col,
    // 					   uv_min, uv_max );
}
void Im_DrawShapeWithHoleFilled(ImDrawList *drawlist, ImU32 col, void *data)
{
    ImPolyHoleShapeData *values = (ImPolyHoleShapeData *)data;
    DrawShapeWithHole(drawlist, values->pts, values->pts_count, col);
}

void RenderNavCursorEx(ImGuiID id, ImDrawShape func, void *data, ImRect display_rect,
                       ImGuiNavRenderCursorFlags flags /*= ImGuiNavRenderCursorFlags_None */)
{
    ImGuiContext &g = *GImGui;
    if (id != g.NavId)
        return;
    if (!g.NavCursorVisible && !(flags & ImGuiNavRenderCursorFlags_AlwaysDraw))
        return;
    if (id == g.LastItemData.ID && (g.LastItemData.ItemFlags & ImGuiItemFlags_NoNav))
        return;
    ImGuiWindow *window = g.CurrentWindow;
    if (window->DC.NavHideHighlightOneFrame)
        return;

    // float rounding = ( flags & ImGuiNavRenderCursorFlags_NoRounding ) ? 0.0f : g.Style.FrameRounding;
    // ImRect display_rect = bb;
    display_rect.ClipWith(window->ClipRect);
    const float thickness = 2.0f;
    if (flags & ImGuiNavRenderCursorFlags_Compact)
    {
        func(window->DrawList, ImGui::GetColorU32(ImGuiCol_NavCursor), thickness, data);
        // window->DrawList->AddRect( display_rect.Min, display_rect.Max, GetColorU32( ImGuiCol_NavCursor ), rounding,
        // 0, thickness );
    }
    else
    {
        const float distance = 3.0f + thickness * 0.5f;
        display_rect.Expand(ImVec2(distance, distance));
        bool fully_visible = window->ClipRect.Contains(display_rect);
        if (!fully_visible)
            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
        // window->DrawList->AddRect( display_rect.Min, display_rect.Max, GetColorU32( ImGuiCol_NavCursor ), rounding,
        // 0, thickness );
        func(window->DrawList, ImGui::GetColorU32(ImGuiCol_NavCursor), thickness, data);
        if (!fully_visible)
            window->DrawList->PopClipRect();
    }
    // ImGuiContext& g = *GImGui;
    // if ( id != g.NavId )
    //	return;
    // if ( g.NavDisableHighlight && !( flags & ImGuiNavHighlightFlags_AlwaysDraw ) )
    //	return;
    // ImGuiWindow* window = g.CurrentWindow;
    // if ( window->DC.NavHideHighlightOneFrame )
    //	return;

    // float rounding = ( flags & ImGuiNavHighlightFlags_NoRounding ) ? 0.0f : g.Style.FrameRounding;
    // display_rect.ClipWith( window->ClipRect );
    // const float thickness = 2.0f;
    // if ( flags & ImGuiNavHighlightFlags_Compact )
    //{
    //	func( window->DrawList, ImGui::GetColorU32( ImGuiCol_NavHighlight ), thickness, data );
    // }
    // else
    //{
    //	const float distance = 3.0f + thickness * 0.5f;
    //	display_rect.Expand( ImVec2( distance, distance ) );
    //	bool fully_visible = window->ClipRect.Contains( display_rect );
    //	if ( !fully_visible )
    //		window->DrawList->PushClipRect( display_rect.Min, display_rect.Max );
    //	func( window->DrawList, ImGui::GetColorU32( ImGuiCol_NavHighlight ), thickness, data );
    //	if ( !fully_visible )
    //		window->DrawList->PopClipRect();
    // }
}
void RenderNavCursorCircle(ImVec2 center, float radius, ImGuiID id,
                           ImGuiNavRenderCursorFlags flags /*= ImGuiNavRenderCursorFlags_None */)
{
    ImCircle data = {center, radius};
    ImRect   display_rect;
    display_rect.Min = center - ImVec2(radius, radius);
    display_rect.Max = center + ImVec2(radius, radius);
    RenderNavCursorEx(id, &Im_DrawCircle, &data, display_rect, flags);
}
void RenderNavHighlightCapsuleH(ImVec2 pos, float length, float radius, ImGuiID id,
                                ImGuiNavRenderCursorFlags flags = ImGuiNavRenderCursorFlags_None)
{
    ImCapsule data = {pos, length, radius};
    ImRect    display_rect;
    display_rect.Min = pos - ImVec2(radius, radius);
    display_rect.Max = pos + ImVec2(radius, radius);
    RenderNavCursorEx(id, &Im_DrawCapsuleH, &data, display_rect, flags);
}
void RenderNavHighlightCapsuleV(ImVec2 pos, float length, float radius, ImGuiID id,
                                ImGuiNavRenderCursorFlags flags = ImGuiNavRenderCursorFlags_None)
{
    ImCapsule data = {pos, length, radius};
    ImRect    display_rect;
    display_rect.Min = pos - ImVec2(radius, radius);
    display_rect.Max = pos + ImVec2(radius, radius);
    RenderNavCursorEx(id, &Im_DrawCapsuleV, &data, display_rect, flags);
}
void RenderNavCursorConvex(ImVec2 *pts, int pts_count, ImGuiID id,
                           ImGuiNavRenderCursorFlags flags /*= ImGuiNavRenderCursorFlags_None */)
{
    ImPolyShapeData data = {pts, pts_count};
    ImRect          display_rect;
    ImComputeRect(&display_rect, pts, pts_count);
    RenderNavCursorEx(id, &Im_DrawShapeConvex, &data, display_rect, flags);
}
void RenderNavCursorConcave(ImVec2 *pts, int pts_count, ImGuiID id,
                            ImGuiNavRenderCursorFlags flags /*= ImGuiNavRenderCursorFlags_None */)
{
    ImPolyShapeData data = {pts, pts_count};
    ImRect          display_rect;
    ImComputeRect(&display_rect, pts, pts_count);
    RenderNavCursorEx(id, &Im_DrawShapeConcave, &data, display_rect, flags);
}
void RenderCursorWithHole(ImVec2 *pts, int pts_count, ImGuiID id,
                          ImGuiNavRenderCursorFlags flags /*= ImGuiNavRenderCursorFlags_None */)
{
    ImPolyHoleShapeData data = {pts, NULL, pts_count, 1, 1};
    ImRect              display_rect;
    ImComputeRect(&display_rect, pts, pts_count);
    RenderNavCursorEx(id, &Im_DrawShapeWithHole, &data, display_rect, flags);
}

void RenderFrameEx(ImU32 fill_col, bool border, ImDrawShape outline, ImDrawShapeFilled fill,
                   ImDrawShapeFilledTex fill_tex, void *data, ImTextureID *tex, ImVec2 uv_min, ImVec2 uv_max)
{
    ImGuiContext &g      = *GImGui;
    ImGuiWindow  *window = g.CurrentWindow;
    if (tex)
        fill_tex(window->DrawList, fill_col, data, *tex, uv_min, uv_max);
    else
        fill(window->DrawList, fill_col, data);
    const float border_size = g.Style.FrameBorderSize;
    if (border && border_size > 0.0f)
    {
        outline(window->DrawList, ImGui::GetColorU32(ImGuiCol_BorderShadow), border_size, data);
        //
        outline(window->DrawList, ImGui::GetColorU32(ImGuiCol_Border), border_size, data);
    }
}
//////////////////////////////////////////////////////////////////////////
// Interactions
//////////////////////////////////////////////////////////////////////////
bool IsTriangleContains(ImVec2 a, ImVec2 b, ImVec2 c, ImVec2 p)
{
    // Compute vectors
    ImVec2 v0 = {c.x - a.x, c.y - a.y};
    ImVec2 v1 = {b.x - a.x, b.y - a.y};
    ImVec2 v2 = {p.x - a.x, p.y - a.y};

    // Compute dot products
    float dot00 = v0.x * v0.y + v0.y * v0.y;
    float dot01 = v0.x * v1.x + v0.y * v1.y;
    float dot02 = v0.x * v2.x + v0.y * v2.y;
    float dot11 = v1.x * v1.x + v1.y * v1.y;
    float dot12 = v1.x * v2.x + v1.y * v2.y;

    // Compute barycentric coordinates
    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float u        = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v        = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // Check if point is in triangle
    return (u >= 0.0f) && (v >= 0.0f) && (u + v < 1.0f);
}

bool IsBoundingBoxWellFormed(const ImVec2 &r_min, const ImVec2 &r_max, ImVec2 *pts, int pts_count)
{
    bool well_form = true;
    for (int k = 0; k < pts_count; ++k) { well_form &= ImRect(r_min, r_max).Contains(pts[k]); }
    return well_form;
}

bool IsMouseHovering(const ImVec2 &r_min, const ImVec2 &r_max, IsContains contains, void *data, bool clip)
{
    ImGuiContext &g = *ImGui::GetCurrentContext();

    // Clip
    ImRect rect_clipped(r_min, r_max);
    if (clip)
        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

    // Hit testing, expanded for touch input
    if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))
        return false;
    if (!contains(g.IO.MousePos, data))
        return false;

    return true;
}

bool ItemHoverable(const ImRect &bb, ImGuiID id, ImGuiItemFlags item_flags, IsContains isContains, void *extra_data)
{
    IM_UNUSED(extra_data);

    ImGuiContext &g      = *GImGui;
    ImGuiWindow  *window = g.CurrentWindow;

    // IM_ASSERT( IsBoundingBoxWellFormed( bb.Min, bb.Max, pts, pts_count ) );

    if (g.HoveredWindow != window)
        return false;
    if (!ImGui::IsMouseHoveringRect(bb.Min, bb.Max))
        return false;
    // IM_ASSERT( IsBoundingBoxWellFormed( bb.Min, bb.Max, pts, pts_count ) );
    if (!IsMouseHovering(bb.Min, bb.Max, isContains, extra_data))
        return false;

    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        return false;
    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        if (!g.ActiveIdFromShortcut)
            return false;

    // Done with rectangle culling so we can perform heavier checks now.
    if (!(item_flags & ImGuiItemFlags_NoWindowHoverableCheck) &&
        !ImGui::IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
    {
        g.HoveredIdIsDisabled = true;
        return false;
    }

    // We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
    // hover test in widgets code. We could also decide to split this function is two.
    if (id != 0)
    {
        // Drag source doesn't report as hovered
        if (g.DragDropActive && g.DragDropPayload.SourceId == id &&
            !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
            return false;

        ImGui::SetHoveredID(id);

        // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
        // This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a
        // front-to-back hit-test.
        if (item_flags & ImGuiItemFlags_AllowOverlap)
        {
            g.HoveredIdAllowOverlap = true;
            if (g.HoveredIdPreviousFrame != id)
                return false;
        }

        // Display shortcut (only works with mouse)
        if (id == g.LastItemData.ID && (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasShortcut))
            if (ImGui::IsItemHovered(ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal))
                ImGui::SetTooltip("%s", ImGui::GetKeyChordName(g.LastItemData.Shortcut));
    }

    // When disabled we'll return false but still set HoveredId
    if (item_flags & ImGuiItemFlags_Disabled)
    {
        // Release active id if turning disabled
        if (g.ActiveId == id && id != 0)
            ImGui::ClearActiveID();
        g.HoveredIdIsDisabled = true;
        return false;
    }

#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    if (id != 0)
    {
        // [DEBUG] Item Picker tool!
        // We perform the check here because reaching is path is rare (1~ time a frame),
        // making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
        // items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
            ImGui::GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
        if (g.DebugItemPickerBreakId == id)
            IM_DEBUG_BREAK();
    }
#endif

    if (g.NavHighlightItemUnderNav && (item_flags & ImGuiItemFlags_NoNavDisableMouseHover) == 0)
        return false;

    return true;
}

bool ButtonBehaviorEx(const ImRect &bb, ImGuiID id, bool *out_hovered, bool *out_held, ImGuiButtonFlags flags,
                      IsContains isContains, void *extra_data)
{
    ImGuiContext &g      = *GImGui;
    ImGuiWindow  *window = ImGui::GetCurrentWindow();

    // Default behavior inherited from item flags
    // Note that _both_ ButtonFlags and ItemFlags are valid sources, so copy one into the item_flags and only check
    // that.
    ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.ItemFlags : g.CurrentItemFlags);
    if (flags & ImGuiButtonFlags_AllowOverlap)
        item_flags |= ImGuiItemFlags_AllowOverlap;

    // Default only reacts to left mouse button
    if ((flags & ImGuiButtonFlags_MouseButtonMask_) == 0)
        flags |= ImGuiButtonFlags_MouseButtonLeft;

    // Default behavior requires click + release inside bounding box
    if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)
        flags |= (item_flags & ImGuiItemFlags_ButtonRepeat) ? ImGuiButtonFlags_PressedOnClick
                                                            : ImGuiButtonFlags_PressedOnDefault_;

    ImGuiWindow *backup_hovered_window    = g.HoveredWindow;
    const bool   flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow &&
                                          g.HoveredWindow->RootWindowDockTree == window->RootWindowDockTree;
    if (flatten_hovered_children)
        g.HoveredWindow = window;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    // Alternate registration spot, for when caller didn't use ItemAdd()
    if (g.LastItemData.ID != id)
        IMGUI_TEST_ENGINE_ITEM_ADD(id, bb, NULL);
#endif

    bool pressed = false;
    bool hovered = ItemHoverable(bb, id, item_flags, isContains, extra_data);

    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers
    // the button
    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) &&
        !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        {
            hovered = true;
            ImGui::SetHoveredID(id);
            if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER &&
                g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER)
            {
                pressed                     = true;
                g.DragDropHoldJustPressedId = id;
                ImGui::FocusWindow(window);
            }
        }

    if (flatten_hovered_children)
        g.HoveredWindow = backup_hovered_window;

    // Mouse handling
    const ImGuiID test_owner_id = (flags & ImGuiButtonFlags_NoTestKeyOwner) ? ImGuiKeyOwner_Any : id;
    if (hovered)
    {
        IM_ASSERT(id != 0); // Lazily check inside rare path.

        // Poll mouse buttons
        // - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.
        // - Technically we only need some values in one code path, but since this is gated by hovered test this is
        // fine.
        int mouse_button_clicked  = -1;
        int mouse_button_released = -1;
        for (int button = 0; button < 3; button++)
            if (flags &
                (ImGuiButtonFlags_MouseButtonLeft
                 << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.
            {
                if (ImGui::IsMouseClicked(button, ImGuiInputFlags_None, test_owner_id) && mouse_button_clicked == -1)
                {
                    mouse_button_clicked = button;
                }
                if (ImGui::IsMouseReleased(button, test_owner_id) && mouse_button_released == -1)
                {
                    mouse_button_released = button;
                }
            }

        // Process initial action
        const bool mods_ok =
            !(flags & ImGuiButtonFlags_NoKeyModsAllowed) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt);
        if (mods_ok)
        {
            if (mouse_button_clicked != -1 && g.ActiveId != id)
            {
                if (!(flags & ImGuiButtonFlags_NoSetKeyOwner))
                    ImGui::SetKeyOwner(ImGui::MouseButtonToKey(mouse_button_clicked), id);
                if (flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere))
                {
                    ImGui::SetActiveID(id, window);
                    g.ActiveIdMouseButton = mouse_button_clicked;
                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
                    {
                        ImGui::SetFocusID(id, window);
                        ImGui::FocusWindow(window);
                    }
                    else
                    {
                        ImGui::FocusWindow(
                            window, ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to
                                                                                 // front, but try to avoid losing NavId
                                                                                 // when navigating a child
                    }
                }
                if ((flags & ImGuiButtonFlags_PressedOnClick) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) &&
                                                                  g.IO.MouseClickedCount[mouse_button_clicked] == 2))
                {
                    pressed = true;
                    if (flags & ImGuiButtonFlags_NoHoldingActiveId)
                        ImGui::ClearActiveID();
                    else
                        ImGui::SetActiveID(id, window); // Hold on ID
                    g.ActiveIdMouseButton = mouse_button_clicked;
                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
                    {
                        ImGui::SetFocusID(id, window);
                        ImGui::FocusWindow(window);
                    }
                    else
                    {
                        ImGui::FocusWindow(
                            window, ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to
                                                                                 // front, but try to avoid losing NavId
                                                                                 // when navigating a child
                    }
                }
            }
            if (flags & ImGuiButtonFlags_PressedOnRelease)
            {
                if (mouse_button_released != -1)
                {
                    const bool has_repeated_at_least_once =
                        (item_flags & ImGuiItemFlags_ButtonRepeat) &&
                        g.IO.MouseDownDurationPrev[mouse_button_released] >=
                            g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
                    if (!has_repeated_at_least_once)
                        pressed = true;
                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
                        ImGui::SetFocusID(id, window); // FIXME: Lack of FocusWindow() call here is inconsistent with
                                                       // other paths. Research why.
                    ImGui::ClearActiveID();
                }
            }

            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer
            // RepeatDelay/RepeatRate settings.
            if (g.ActiveId == id && (item_flags & ImGuiItemFlags_ButtonRepeat))
                if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f &&
                    ImGui::IsMouseClicked(g.ActiveIdMouseButton, ImGuiInputFlags_Repeat, test_owner_id))
                    pressed = true;
        }

        if (pressed && g.IO.ConfigNavCursorVisibleAuto)
            g.NavCursorVisible = false;
    }

    // Keyboard/Gamepad navigation handling
    // We report navigated and navigation-activated items as hovered but we don't set g.HoveredId to not interfere with
    // mouse.
    if (g.NavId == id && g.NavCursorVisible && g.NavHighlightItemUnderNav)
        if (!(flags & ImGuiButtonFlags_NoHoveredOnFocus))
            hovered = true;
    if (g.NavActivateDownId == id)
    {
        bool nav_activated_by_code   = (g.NavActivateId == id);
        bool nav_activated_by_inputs = (g.NavActivatePressedId == id);
        if (!nav_activated_by_inputs && (item_flags & ImGuiItemFlags_ButtonRepeat))
        {
            // Avoid pressing multiple keys from triggering excessive amount of repeat events
            const ImGuiKeyData *key1 = ImGui::GetKeyData(ImGuiKey_Space);
            const ImGuiKeyData *key2 = ImGui::GetKeyData(ImGuiKey_Enter);
            const ImGuiKeyData *key3 = ImGui::GetKeyData(ImGuiKey_NavGamepadActivate);
            const float         t1   = ImMax(ImMax(key1->DownDuration, key2->DownDuration), key3->DownDuration);
            nav_activated_by_inputs =
                ImGui::CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
        }
        if (nav_activated_by_code || nav_activated_by_inputs)
        {
            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
            pressed = true;
            ImGui::SetActiveID(id, window);
            g.ActiveIdSource = g.NavInputSource;
            if (!(flags & ImGuiButtonFlags_NoNavFocus) && !(g.NavActivateFlags & ImGuiActivateFlags_FromShortcut))
                ImGui::SetFocusID(id, window);
            if (g.NavActivateFlags & ImGuiActivateFlags_FromShortcut)
                g.ActiveIdFromShortcut = true;
        }
    }

    // Process while held
    bool held = false;
    if (g.ActiveId == id)
    {
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        {
            if (g.ActiveIdIsJustActivated)
                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;

            const int mouse_button = g.ActiveIdMouseButton;
            if (mouse_button == -1)
            {
                // Fallback for the rare situation were g.ActiveId was set programmatically or from another widget (e.g.
                // #6304).
                ImGui::ClearActiveID();
            }
            else if (ImGui::IsMouseDown(mouse_button, test_owner_id))
            {
                held = true;
            }
            else
            {
                bool release_in       = hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) != 0;
                bool release_anywhere = (flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;
                if ((release_in || release_anywhere) && !g.DragDropActive)
                {
                    // Report as pressed when releasing the mouse (this is the most common path)
                    bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) &&
                                                   g.IO.MouseReleased[mouse_button] &&
                                                   g.IO.MouseClickedLastCount[mouse_button] == 2;
                    bool is_repeating_already = (item_flags & ImGuiItemFlags_ButtonRepeat) &&
                                                g.IO.MouseDownDurationPrev[mouse_button] >=
                                                    g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
                    bool is_button_avail_or_owned =
                        ImGui::TestKeyOwner(ImGui::MouseButtonToKey(mouse_button), test_owner_id);
                    if (!is_double_click_release && !is_repeating_already && is_button_avail_or_owned)
                        pressed = true;
                }
                ImGui::ClearActiveID();
            }
            if (!(flags & ImGuiButtonFlags_NoNavFocus) && g.IO.ConfigNavCursorVisibleAuto)
                g.NavCursorVisible = false;
        }
        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
        {
            // When activated using Nav, we hold on the ActiveID until activation button is released
            if (g.NavActivateDownId == id)
                held = true; // hovered == true not true as we are already likely hovered on direct activation.
            else
                ImGui::ClearActiveID();
        }
        if (pressed)
            g.ActiveIdHasBeenPressedBefore = true;
    }

    // Activation highlight (this may be a remote activation)
    if (g.NavHighlightActivatedId == id)
        hovered = true;

    if (out_hovered)
        *out_hovered = hovered;
    if (out_held)
        *out_held = held;

    return pressed;
}

bool ButtonBehaviorCircle(ImVec2 center, float radius, ImGuiID id, bool *out_hovered, bool *out_held,
                          ImGuiButtonFlags flags)
{
    ImRect bb;
    bb.Min          = center - ImVec2(radius, radius);
    bb.Max          = center + ImVec2(radius, radius);
    ImCircle circle = {center, radius};
    return ButtonBehaviorEx(bb, id, out_hovered, out_held, flags, &Im_IsCircleContains, &circle);
}

bool ButtonBehaviorCapsuleH(ImVec2 pos, float length, float radius, ImGuiID id, bool *out_hovered, bool *out_held,
                            ImGuiButtonFlags flags)
{
    ImRect bb;
    bb.Min            = pos - ImVec2(radius, radius);
    bb.Max            = pos + ImVec2(radius + length, radius);
    ImCapsule capsule = {pos, length, radius};
    return ButtonBehaviorEx(bb, id, out_hovered, out_held, flags, &Im_IsCapsuleHContains, &capsule);
}

bool ButtonBehaviorCapsuleV(ImVec2 pos, float length, float radius, ImGuiID id, bool *out_hovered, bool *out_held,
                            ImGuiButtonFlags flags)
{
    ImRect bb;
    bb.Min            = pos - ImVec2(radius, radius);
    bb.Max            = pos + ImVec2(radius, radius + length);
    ImCapsule capsule = {pos, length, radius};
    return ButtonBehaviorEx(bb, id, out_hovered, out_held, flags, &Im_IsCapsuleVContains, &capsule);
}

bool ButtonBehaviorConvex(ImVec2 *pts, int pts_count, ImGuiID id, bool *out_hovered, bool *out_held,
                          ImGuiButtonFlags flags)
{
    ImRect bb;
    ImComputeRect(&bb, pts, pts_count);
    ImPolyShapeData data = {pts, pts_count};
    return ButtonBehaviorEx(bb, id, out_hovered, out_held, flags, &Im_IsPolyConvexContains, &data);
}

bool ButtonBehaviorConcave(ImVec2 *pts, int pts_count, ImGuiID id, bool *out_hovered, bool *out_held,
                           ImGuiButtonFlags flags)
{
    ImRect bb;
    ImComputeRect(&bb, pts, pts_count);
    ImPolyShapeData data = {pts, pts_count};
    return ButtonBehaviorEx(bb, id, out_hovered, out_held, flags, &Im_IsPolyConcaveContains, &data);
}

bool ButtonBehaviorWithHole(ImVec2 *pts, int pts_count, ImGuiID id, bool *out_hovered, bool *out_held,
                            ImGuiButtonFlags flags)
{
    ImRect bb;
    ImComputeRect(&bb, pts, pts_count);
    ImPolyHoleShapeData data = {pts, NULL, pts_count, 1, 1};
    return ButtonBehaviorEx(bb, id, out_hovered, out_held, flags, &Im_IsPolyWithHoleContains, &data);
}

//////////////////////////////////////////////////////////////////////////
// Widgets
//////////////////////////////////////////////////////////////////////////
bool ButtonEx(const char *label, const ImVec2 &size_arg, ImRect src_bb, ImVec2 text_offset, ImGuiButtonFlags flags,
              IsContains isContains, ImDrawShape draw_outline, ImDrawShapeFilled draw_fill,
              ImDrawShapeFilledTex draw_fill_tex, ImInlineOffset offset, FromRect from_rect, void *extra_data,
              ImTextureID *tex, ImVec2 uv_min, ImVec2 uv_max)
{
    ImGuiWindow *window = ImGui::GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext     &g          = *GImGui;
    const ImGuiStyle &style      = g.Style;
    const ImGuiID     id         = window->GetID(label);
    const ImVec2      label_size = ImGui::CalcTextSize(label, NULL, true);

    ImVec2 pos = window->DC.CursorPos;
    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) &&
        style.FramePadding.y <
            window->DC.CurrLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so
                                               // that text baseline matches (bit hacky, since it shouldn't be a flag)
        pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;
    ImVec2 size = ImGui::CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f,
                                      label_size.y + style.FramePadding.y * 2.0f);

    ImRect bb(pos, pos + size);

    ImPolyHoleShapeData data; // Largest struct. Not really an ImPolyHoleShapeData
    if (extra_data)
    {
        offset(extra_data, pos);
    }
    else
    {
        from_rect(bb, &data);
    }
    void *used_data = extra_data ? extra_data : &data;

    if (extra_data)
    {
        ImRect shape_bb = src_bb;
        shape_bb.Translate(pos);
        bb.Add(shape_bb);
        size.x = ImMax(size.x, bb.GetWidth());
        size.y = ImMax(size.y, bb.GetHeight());
    }

    ImGui::ItemSize(size, style.FramePadding.y);
    if (!ImGui::ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehaviorEx(bb, id, &hovered, &held, flags, isContains, used_data);

    // Render
    const ImU32 col = ImGui::GetColorU32((held && hovered) ? ImGuiCol_ButtonActive
                                         : hovered         ? ImGuiCol_ButtonHovered
                                                           : ImGuiCol_Button);
    RenderNavCursorEx(id, draw_outline, used_data, bb, 0);
    if (tex)
        draw_fill_tex(window->DrawList, IM_COL32_WHITE, used_data, *tex, uv_min, uv_max);
    else
        RenderFrameEx(col, true, draw_outline, draw_fill, draw_fill_tex, used_data, tex, uv_min, uv_max);

    if (g.LogEnabled)
        ImGui::LogSetNextTextDecoration("[", "]");
    ImGui::RenderTextClipped(text_offset + bb.Min + style.FramePadding, text_offset + bb.Max - style.FramePadding,
                             label, NULL, &label_size, style.ButtonTextAlign, &bb);

    // Automatically close popups
    // if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
    //    CloseCurrentPopup();

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
    return pressed;
}
bool ButtonExCircle(const char *label, float radius, ImGuiButtonFlags flags)
{
    return ButtonEx(label, {2.0f * radius, 2.0f * radius}, {}, ImVec2(0.0f, 0.0f), flags, &Im_IsCircleContains,
                    &Im_DrawCircle, &Im_DrawCircleFilled, &Im_DrawCircleFilledTex, &Im_InlineOffsetCircle,
                    &Im_CircleFromRect, NULL);
}
bool ButtonExCapsuleH(const char *label, float length, float thickness, ImGuiButtonFlags flags)
{
    return ButtonEx(label, {length, ImMin(thickness, length)}, {}, ImVec2(0.0f, 0.0f), flags, &Im_IsCapsuleHContains,
                    &Im_DrawCapsuleH, &Im_DrawCapsuleHFilled, &Im_DrawCapsuleHFilledTex, &Im_InlineOffsetCapsuleH,
                    &Im_CapsuleHFromRect, NULL);
}
bool ButtonExCapsuleV(const char *label, float length, float thickness, ImGuiButtonFlags flags)
{
    return ButtonEx(label, {ImMin(thickness, length), length}, {}, ImVec2(0.0f, 0.0f), flags, &Im_IsCapsuleVContains,
                    &Im_DrawCapsuleV, &Im_DrawCapsuleVFilled, &Im_DrawCapsuleVFilledTex, &Im_InlineOffsetCapsuleV,
                    &Im_CapsuleVFromRect, NULL);
}
bool ButtonExConvex(const char *label, const ImVec2 &size_arg, ImVec2 *pts, int pts_count, ImGuiButtonFlags flags)
{
    ImPolyShapeData data = {pts, pts_count};
    ImRect          bb;
    ImComputeRect(&bb, pts, pts_count);
    return ButtonEx(label, size_arg, bb, ImVec2(0.0f, 0.0f), flags, &Im_IsPolyConvexContains, &Im_DrawShapeConvex,
                    &Im_DrawShapeConvexFilled, &Im_DrawShapeConvexFilledTex, &Im_InlineOffsetConvex, NULL, &data);
}
bool ButtonExConcave(const char *label, const ImVec2 &size_arg, ImVec2 *pts, int pts_count, ImVec2 text_offset,
                     ImGuiButtonFlags flags)
{
    ImPolyShapeData data = {pts, pts_count};
    ImRect          bb;
    ImComputeRect(&bb, pts, pts_count);
    return ButtonEx(label, size_arg, bb, text_offset, flags, &Im_IsPolyConcaveContains, &Im_DrawShapeConcave,
                    &Im_DrawShapeConcaveFilled, &Im_DrawShapeConcaveFilledTex, &Im_InlineOffsetConcave, NULL, &data);
}
bool ButtonExWithHole(const char *label, const ImVec2 &size_arg, ImVec2 *pts, int pts_count, ImVec2 text_offset,
                      ImGuiButtonFlags flags)
{
    ImPolyHoleShapeData data = {pts, NULL, pts_count, 1, 1};
    ImRect              bb;
    ImComputeRect(&bb, pts, pts_count);
    return ButtonEx(label, size_arg, bb, text_offset, flags, &Im_IsPolyWithHoleContains, &Im_DrawShapeWithHole,
                    &Im_DrawShapeWithHoleFilled, NULL, &Im_InlineOffsetWithHole, NULL, &data);
}

bool ImageButtonExCircle(const char *label, ImTextureID tex, float radius, ImGuiButtonFlags flags, ImU32 col,
                         ImVec2 uv_min, ImVec2 uv_max)
{
    ImVec2 pos = ImGui::GetCursorScreenPos();
    bool   out = ImWidgets::ButtonExCircle(label, radius, 0);

    ImCircle circle = {pos + ImVec2(radius, radius), radius};
    Im_DrawCircleFilledTex(ImGui::GetWindowDrawList(), IM_COL32_WHITE, &circle, tex, uv_min, uv_max);

    return out;
    // return ButtonEx( label, { 2.0f * radius, 2.0f * radius }, {}, ImVec2( 0.0f, 0.0f ), flags,
    //				 &Im_IsCircleContains, &Im_DrawCircle, &Im_DrawCircleFilled, &Im_DrawCircleFilledTex,
    //&Im_InlineOffsetCircle, &Im_CircleFromRect, 				 NULL, &tex );
}
bool ImageButtonExCapsuleH(const char *label, ImTextureID tex, float length, float thickness, ImGuiButtonFlags flags,
                           ImU32 col, ImVec2 uv_min, ImVec2 uv_max)
{
    ImVec2 pos = ImGui::GetCursorScreenPos();
    bool   out = ButtonExCapsuleH(label, length, thickness, 0);

    ImCapsule cap = {pos + ImVec2(thickness * 0.5f, thickness * 0.5f), length - thickness, thickness * 0.5f * 0.9f};
    Im_DrawCapsuleHFilledTex(ImGui::GetWindowDrawList(), IM_COL32_WHITE, &cap, tex, uv_min, uv_max);

    return out;
}
bool ImageButtonExCapsuleV(const char *label, ImTextureID tex, float length, float thickness, ImGuiButtonFlags flags,
                           ImU32 col, ImVec2 uv_min, ImVec2 uv_max)
{
    ImVec2 pos = ImGui::GetCursorScreenPos();
    bool   out = ButtonExCapsuleV(label, length, thickness, flags);

    ImCapsule cap = {pos + ImVec2(thickness * 0.5f, thickness * 0.5f), length - thickness, thickness * 0.5f * 0.9f};
    Im_DrawCapsuleVFilledTex(ImGui::GetWindowDrawList(), IM_COL32_WHITE, &cap, tex, uv_min, uv_max);

    return out;
}
bool ImageButtonExConvex(const char *label, ImTextureID tex, const ImVec2 &size_arg, ImVec2 *pts, int pts_count,
                         ImGuiButtonFlags flags, ImU32 col, ImVec2 uv_min, ImVec2 uv_max)
{
    ImPolyShapeData data = {pts, pts_count};
    ImRect          bb;
    ImComputeRect(&bb, pts, pts_count);
    return ButtonEx(label, size_arg, bb, ImVec2(0.0f, 0.0f), flags, &Im_IsPolyConvexContains, &Im_DrawShapeConvex,
                    &Im_DrawShapeConvexFilled, &Im_DrawShapeConvexFilledTex, &Im_InlineOffsetConvex, NULL, &data, &tex);
}
bool ImageButtonExConcave(const char *label, ImTextureID tex, const ImVec2 &size_arg, ImVec2 *pts, int pts_count,
                          ImVec2 text_offset, ImGuiButtonFlags flags, ImU32 col, ImVec2 uv_min, ImVec2 uv_max)
{
    ImPolyShapeData data = {pts, pts_count};
    ImRect          bb;
    ImComputeRect(&bb, pts, pts_count);
    return ButtonEx(label, size_arg, bb, text_offset, flags, &Im_IsPolyConcaveContains, &Im_DrawShapeConcave,
                    &Im_DrawShapeConcaveFilled, &Im_DrawShapeConcaveFilledTex, &Im_InlineOffsetConcave, NULL, &data,
                    &tex);
}

ImU32 ImInternalHueMaskingFunc(float const xx, void *pUserData)
{
    float *values   = (float *)pUserData;
    float  hueAlpha = values[0];
    float  centerV  = values[1];
    float  widthV   = values[2];
    float  left     = values[3];
    float  right    = values[4];
    float  x        = ImFmod(xx, 1.0f);
    float  val;
    if (x < centerV - widthV && x > centerV - widthV - left)
    {
        val = ImClamp((centerV * (-1 + hueAlpha) + left + widthV + x - hueAlpha * (widthV + x)) / left, hueAlpha, 1.0f);
    }
    else if (x < centerV + widthV + right && x > centerV + widthV)
    {
        val = ImClamp((centerV - centerV * hueAlpha + right + widthV - hueAlpha * widthV + (-1 + hueAlpha) * x) / right,
                      hueAlpha, 1.0f);
    }
    else if (x > centerV - widthV - left && x < centerV + widthV + right)
    {
        val = 1.0f;
    }
    else if (centerV + widthV + right > 1.0f)
    {
        val = ImClamp(
            (centerV - centerV * hueAlpha + right + widthV - hueAlpha * widthV + (-1 + hueAlpha) * (x + 1.0f)) / right,
            hueAlpha, 1.0f);
    }
    else if (centerV - widthV - left < 0.0f)
    {
        val = ImClamp((centerV * (-1 + hueAlpha) + left + widthV + x - 1.0f - hueAlpha * (widthV + x - 1.0f)) / left,
                      hueAlpha, 1.0f);
    }
    else
    {
        val = hueAlpha;
    }
    return IM_COL32(0, 0, 0, ImPow(1.0f - val, 1.0f / 2.2f) * 255);
}

bool HueSelector(char const *label, float hueHeight, float cursorHeight, float *hueCenter, float *hueWidth,
                 float *featherLeft, float *featherRight, int division, float alpha, float hideHueAlpha, float offset)
{
    ImGuiWindow *window = ImGui::GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext     &g     = *GImGui;
    const ImGuiStyle &style = g.Style;
    const ImGuiID     id    = window->GetID(label);
    const float       w     = ImGui::CalcItemWidth();

    const float cursorSize = cursorHeight;

    ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);
    label_size.y      = ImMax(label_size.y, hueHeight);

    const ImRect frame_bb(window->DC.CursorPos,
                          window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
    const ImRect total_bb(
        frame_bb.Min,
        frame_bb.Max +
            ImVec2(cursorSize + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), cursorSize));

    const ImRect hue_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, hueHeight));
    const ImRect cursor_bb(ImVec2(hue_bb.Min.x, hue_bb.Max.y), hue_bb.Max + ImVec2(0.0f, cursorHeight));
    const ImRect full_bb(hue_bb.Min, cursor_bb.Max);

    const ImVec2 curPos = window->DC.CursorPos;

    ImGui::ItemSize(total_bb, style.FramePadding.y);
    if (!ImGui::ItemAdd(total_bb, id, &frame_bb, 0))
        return false;

    const bool hovered = ImGui::ItemHoverable(full_bb, id, g.LastItemData.ItemFlags);

    // Tabbing or CTRL-clicking on Slider turns it into an input box
    const bool clicked     = hovered && ImGui::IsMouseClicked(0, ImGuiInputFlags_None, id);
    const bool make_active = (clicked || g.NavActivateId == id);
    if (make_active && clicked)
        ImGui::SetKeyOwner(ImGuiKey_MouseLeft, id);

    if (make_active)
    {
        ImGui::SetActiveID(id, window);
        ImGui::SetFocusID(id, window);
        ImGui::FocusWindow(window);
        g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    }

    // Draw frame
    const ImU32 frame_col = ImGui::GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive
                                               : hovered        ? ImGuiCol_FrameBgHovered
                                                                : ImGuiCol_FrameBg);
    ImGui::RenderNavCursor(full_bb, id);
    ImGui::RenderFrame(full_bb.Min, full_bb.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect     grab_bb;
    float      zero = 0.0f;
    float      one  = 1.0f;
    const bool value_changed =
        ImGui::SliderBehavior(full_bb, id, ImGuiDataType_Float, hueCenter, &zero, &one, NULL,
                              ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat, &grab_bb);
    if (value_changed)
        ImGui::MarkItemEdited(id);

    if (label_size.x > 0.0f)
        ImGui::RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y),
                          label);

    float red[] = {1.0f, 0.0f, 0.0f};
    DrawHueBand(window->DrawList, hue_bb.Min, hue_bb.GetSize(), division, &red[0], alpha, offset);

    float center   = ImClamp(ImFmod(*hueCenter + offset, 1.0f), 0.0f, 1.0f - 1e-4f);
    float width    = ImClamp(*hueWidth, 0.0f, 0.5f - 1e-4f);
    float featherL = ImClamp(*featherLeft, 0.0f, 0.5f - 1e-4f);
    float featherR = ImClamp(*featherRight, 0.0f, 0.5f - 1e-4f);

    ImWidgetsStyle &dwstyle = ImWidgets::GetStyle();

    float xCenter = curPos.x + center * w;
    if (width == 0.0f)
    {
        // TODO: add style for thickness or color
        window->DrawList->AddLine(ImVec2(xCenter, curPos.y), ImVec2(xCenter, curPos.y + hueHeight),
                                  IM_COL32(0, 0, 0, 255), dwstyle.HueSelector_Thickness_ZeroWidth);
    }
    else
    {
        float data[] = {hideHueAlpha, center, width, featherL, featherR};
        DrawProceduralColor1DBilinear(window->DrawList, ImInternalHueMaskingFunc, &data[0], 0.0f, 1.0f, hue_bb.Min,
                                      hue_bb.GetSize(), division);
    }

    // Render grab
    float pos = ImLerp(cursor_bb.Min.x, cursor_bb.Max.x, *hueCenter);
    DrawTriangleCursorFilled(window->DrawList, ImVec2(pos, cursor_bb.Min.y), 0.0f, cursorSize,
                             IM_COL32(255, 255, 255, 255));

    return value_changed;
}

bool SliderNScalar(char const *label, ImGuiDataType data_type, void *ordered_value, int value_count, void *p_min,
                   void *p_max, float cursor_width, bool show_hover_by_region)
{
    ImGuiWindow *window = ImGui::GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT(value_count > 1);

    ImGuiContext     &g     = *GImGui;
    const ImGuiStyle &style = g.Style;
    const ImGuiID     id    = window->GetID(label);
    const float       w     = ImGui::CalcItemWidth();

    ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);

    const ImRect frame_bb(window->DC.CursorPos + ImVec2(cursor_width, 0.0f),
                          window->DC.CursorPos + ImVec2(w - cursor_width, label_size.y + style.FramePadding.y * 2.0f));
    const ImRect total_bb(frame_bb.Min,
                          frame_bb.Max +
                              ImVec2((label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), 0.0f));

    // const ImVec2 curPos = window->DC.CursorPos;

    float fMin = ScalarToFloat(data_type, (ImU64 *)p_min);
    float fMax = ScalarToFloat(data_type, (ImU64 *)p_max);

    ImVector<ImGuiID> ids;
    ids.resize(value_count);
    ids[0] = window->GetID(id);
    for (int k = 1; k < value_count; ++k) { ids[k] = window->GetID(ids[k - 1]); }

    ImVector<float> centers;
    centers.resize(value_count + 1);
    centers[0] = Rescale01(fMin, fMin, fMax);
    for (int k = 1; k < value_count; ++k)
    {
        float x0   = ScalarIndirectToFloat(data_type, ordered_value, k - 1);
        float x1   = ScalarIndirectToFloat(data_type, ordered_value, k);
        centers[k] = Rescale01(x0 * 0.5f + x1 * 0.5f, fMin, fMax);
    }
    centers[value_count] = Rescale01(fMax, fMin, fMax);

    ImVector<ImRect> drag_bbs;
    drag_bbs.resize(value_count);
    for (int k = 1; k <= value_count; ++k)
    {
        drag_bbs[k - 1] = ImRect(ImVec2(ImLerp(frame_bb.Min.x, frame_bb.Max.x, centers[k - 1]), frame_bb.Min.y),
                                 ImVec2(ImLerp(frame_bb.Min.x, frame_bb.Max.x, centers[k]), frame_bb.Max.y));
    }
    // srand( 97 );
    // for ( int k = 0; k < value_count; ++k )
    //{
    //	ImRect& bb = drag_bbs[ k ];
    //	window->DrawList->AddRect( bb.Min, bb.Max, IM_COL32( rand() % 255, rand() % 255, rand() % 255, 255 ), 0, 0, 5 );
    // }
    // srand( 97 );
    // for ( int k = 0; k < value_count; ++k )
    //{
    //	float x = ImLerp( frame_bb.Min.x, frame_bb.Max.x, ScalarIndirectToFloat( data_type, ordered_value, k ) / (
    // ScalarToFloat( data_type, ( ImU64* )p_max ) - ScalarToFloat( data_type, ( ImU64* )p_min ) ) );
    //	window->DrawList->AddLine( ImVec2( x, frame_bb.Min.y ), ImVec2( x, frame_bb.Max.y ), IM_COL32( rand() % 255,
    // rand() % 255, rand() % 255, 255 ), 5 );
    // }

    ImGui::ItemSize(total_bb, style.FramePadding.y);

    // Slider behavior
    ImRect grab_bb;
    // float zero = 0.0f;
    // float one = 1.0f;
    bool value_changed = false;
    bool full_hovered  = false;
    bool is_active     = false;
    for (int k = 0; k < value_count; ++k)
    {
        ImRect &bb = drag_bbs[k];

        if (!ImGui::ItemAdd(total_bb, ids[k], &bb, 0))
            return false;

        const bool hovered = ImGui::ItemHoverable(bb, ids[k], g.LastItemData.ItemFlags);
        full_hovered |= hovered;

        // Tabbing or CTRL-clicking on Slider turns it into an input box
        const bool clicked     = hovered && ImGui::IsMouseClicked(0, ImGuiInputFlags_None, ids[k]);
        const bool make_active = (clicked || g.NavActivateId == ids[k]);
        if (make_active && clicked)
            ImGui::SetKeyOwner(ImGuiKey_MouseLeft, ids[k]);

        if (make_active)
        {
            ImGui::SetActiveID(ids[k], window);
            ImGui::SetFocusID(ids[k], window);
            ImGui::FocusWindow(window);
            g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
        }

        is_active |= (g.ActiveId == ids[k]);
        if (show_hover_by_region)
        {
            // Draw frame
            const ImU32 frame_col = ImGui::GetColorU32(g.ActiveId == ids[k] ? ImGuiCol_FrameBgActive
                                                       : hovered            ? ImGuiCol_FrameBgHovered
                                                                            : ImGuiCol_FrameBg);
            ImGui::RenderNavCursor(bb, ids[k]);
            ImGui::RenderFrame(bb.Min, bb.Max, frame_col, true, g.Style.FrameRounding);
        }

        ImU64 currentValue = ScalarIndirectToScalar(data_type, ordered_value, k);
        float local_min    = bb.Min.x;
        float local_max    = bb.Max.x;
        local_min          = Rescale(local_min, frame_bb.Min.x, frame_bb.Max.x, fMin, fMax);
        local_max          = Rescale(local_max, frame_bb.Min.x, frame_bb.Max.x, fMin, fMax);
        ImU64 v_local_min  = FloatToScalar(data_type, local_min);
        ImU64 v_local_max  = FloatToScalar(data_type, local_max);
        float signet01;
        if (k == 0)
            signet01 = 0.0f;
        else if (k == value_count - 1)
            signet01 = 1.0f;
        else
            signet01 = 0.5f;
        float x = ImLerp(frame_bb.Min.x, frame_bb.Max.x,
                         ScalarIndirectToFloat(data_type, ordered_value, k) /
                             (ScalarToFloat(data_type, (ImU64 *)p_max) - ScalarToFloat(data_type, (ImU64 *)p_min)));
        DrawSignetFilledCursor(window->DrawList, ImVec2(x, frame_bb.Min.y), cursor_width, frame_bb.GetHeight(),
                               1.0f / 3.0f, signet01, 0.0f, IM_COL32(255, 0, 0, 255));
        bool current_value_changed =
            ImGui::SliderBehavior(bb, ids[k], ImGuiDataType_Float, &currentValue, &v_local_min, &v_local_max, NULL,
                                  ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat, &grab_bb);
        if (current_value_changed)
        {
            SetScalarIndirect(data_type, ordered_value, k, &currentValue);
            ImGui::MarkItemEdited(ids[k]);
        }
        value_changed |= current_value_changed;
    }
    if (!show_hover_by_region)
    {
        const ImU32 frame_col = ImGui::GetColorU32(is_active      ? ImGuiCol_FrameBgActive
                                                   : full_hovered ? ImGuiCol_FrameBgHovered
                                                                  : ImGuiCol_FrameBg);
        ImGui::RenderNavCursor(frame_bb, id);
        ImGui::RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);
    }
    for (int k = 0; k < value_count; ++k)
    {
        // ImRect& bb = drag_bbs[ k ];

        float signet01;
        if (k == 0)
            signet01 = 0.0f;
        else if (k == value_count - 1)
            signet01 = 1.0f;
        else
            signet01 = 0.5f;
        float x = ImLerp(frame_bb.Min.x, frame_bb.Max.x,
                         ScalarIndirectToFloat(data_type, ordered_value, k) /
                             (ScalarToFloat(data_type, (ImU64 *)p_max) - ScalarToFloat(data_type, (ImU64 *)p_min)));
        DrawSignetFilledCursor(window->DrawList, ImVec2(x, frame_bb.Min.y), cursor_width, frame_bb.GetHeight(),
                               1.0f / 3.0f, signet01, 0.0f, IM_COL32(255, 0, 0, 255));
    }

    if (label_size.x > 0.0f)
        ImGui::RenderText(
            ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x + cursor_width, frame_bb.Min.y + style.FramePadding.y),
            label);

    return false;
}

bool SliderNFloat(char const *label, float *ordered_value, int value_count, float v_min, float v_max,
                  float cursor_width, bool show_hover_by_region)
{
    return SliderNScalar(label, ImGuiDataType_Float, ordered_value, value_count, &v_min, &v_max, cursor_width,
                         show_hover_by_region);
}

bool SliderNInt(char const *label, int *ordered_value, int value_count, int v_min, int v_max, float cursor_width,
                bool show_hover_by_region)
{
    return SliderNScalar(label, ImGuiDataType_S32, ordered_value, value_count, &v_min, &v_max, cursor_width,
                         show_hover_by_region);
}

// TODO: Add bool flipY
bool Slider2DScalar(char const *label, ImGuiDataType data_type, void *p_valueX, void *p_valueY, void *p_minX,
                    void *p_maxX, void *p_minY, void *p_maxY)
{
    ImGuiWindow *window = ImGui::GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT(ScalarToFloat(data_type, (ImU64 *)p_minX) < ScalarToFloat(data_type, (ImU64 *)p_maxX));
    IM_ASSERT(ScalarToFloat(data_type, (ImU64 *)p_minY) < ScalarToFloat(data_type, (ImU64 *)p_maxY));

    ImGuiContext     &g     = *GImGui;
    const ImGuiStyle &style = g.Style;
    const ImGuiID     id    = window->GetID(label);
    ImGuiID           idX   = window->GetID(id);
    ImGuiID           idY   = window->GetID(idX);
    const float       w     = ImGui::CalcItemWidth();

    ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);

    // TODO: Move those to style
    float downScale        = 0.75f;
    float dragX_placement  = 0.75f;
    float dragY_placement  = 0.75f;
    float dragX_thickness  = 8.0f;
    float dragY_thickness  = 8.0f;
    float border_thickness = 2.0f;
    float line_thickness   = 2.0f;
    float text_lerp_x      = 0.5f;
    float text_lerp_y      = 0.5f;
    float cursor_radius    = 4.0f;
    int   cursor_segments  = 4;
    // ImVec4 vBlue( 70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f ); // TODO: choose from style
    ImVec4 vBlue(91.0f / 255.0f, 194.0f / 255.0f, 231.0f / 255.0f, 1.0f);   // TODO: choose from style
    ImVec4 vOrange(255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f, 1.0f); // TODO: choose from style
    ImU32  uBlue      = ImGui::GetColorU32(vBlue);
    ImU32  uOrange    = ImGui::GetColorU32(vOrange);
    float  fCursorOff = 16.0f;

    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, w));
    const ImRect frame_bb_drag(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w * downScale, w * downScale));
    const ImRect total_bb(frame_bb.Min,
                          frame_bb.Max +
                              ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    const ImRect frame_bb_dragX(
        ImVec2(frame_bb_drag.Min.x, ImLerp(frame_bb_drag.Max.y, frame_bb.Max.y, dragX_placement)),
        ImVec2(frame_bb_drag.Max.x, ImLerp(frame_bb_drag.Max.y, frame_bb.Max.y, dragX_placement) + dragX_thickness));
    const ImRect frame_bb_dragY(
        ImVec2(ImLerp(frame_bb_drag.Max.x, frame_bb.Max.x, dragY_placement), frame_bb_drag.Min.y),
        ImVec2(ImLerp(frame_bb_drag.Max.x, frame_bb.Max.x, dragY_placement) + dragY_thickness, frame_bb_drag.Max.y));

    float fXLimit = fCursorOff / frame_bb_drag.GetWidth();
    float fYLimit = fCursorOff / frame_bb_drag.GetHeight();

    // const ImVec2 curPos = window->DC.CursorPos;

    ImGui::ItemSize(total_bb, style.FramePadding.y);
    if (!ImGui::ItemAdd(total_bb, id, &frame_bb, 0))
        return false;

    bool hovered = ImGui::ItemHoverable(frame_bb_drag, id, g.LastItemData.ItemFlags);

    bool clicked     = hovered && ImGui::IsMouseClicked(0, ImGuiInputFlags_None, id);
    bool make_active = (clicked || g.NavActivateId == id);
    if (make_active && clicked)
        ImGui::SetKeyOwner(ImGuiKey_MouseLeft, id);

    if (make_active)
    {
        ImGui::SetActiveID(id, window);
        ImGui::SetFocusID(id, window);
        ImGui::FocusWindow(window);
        g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    }

    // Draw frame
    ImU32 frame_col = ImGui::GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive
                                         : hovered        ? ImGuiCol_FrameBgHovered
                                                          : ImGuiCol_FrameBg);
    ImGui::RenderNavCursor(frame_bb_drag, id);
    ImGui::RenderFrame(frame_bb_drag.Min, frame_bb_drag.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect grab_bbX;
    ImRect grab_bbY;
    // float zero = 0.0f;
    // float one = 1.0f;
    bool value_changedX = ImGui::SliderBehavior(frame_bb_drag, id, data_type, p_valueX, p_minX, p_maxX, NULL,
                                                ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat, &grab_bbX);
    bool value_changedY = ImGui::SliderBehavior(
        frame_bb_drag, id, data_type, p_valueY, p_minY, p_maxY, NULL,
        ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat | ImGuiSliderFlags_Vertical, &grab_bbY);
    if (value_changedX || value_changedY)
        ImGui::MarkItemEdited(id);

    if (!ImGui::ItemAdd(total_bb, idX, &frame_bb_dragX, 0))
        return false;

    hovered = ImGui::ItemHoverable(frame_bb_dragX, idX, g.LastItemData.ItemFlags);

    clicked     = hovered && ImGui::IsMouseClicked(0, ImGuiInputFlags_None, idX);
    make_active = (clicked || g.NavActivateId == idX);
    if (make_active && clicked)
        ImGui::SetKeyOwner(ImGuiKey_MouseLeft, idX);

    if (make_active)
    {
        ImGui::SetActiveID(idX, window);
        ImGui::SetFocusID(idX, window);
        ImGui::FocusWindow(window);
        g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    }
    frame_col = ImGui::GetColorU32(g.ActiveId == idX ? ImGuiCol_FrameBgActive
                                   : hovered         ? ImGuiCol_FrameBgHovered
                                                     : ImGuiCol_FrameBg);
    bool value_changedXS =
        ImGui::SliderBehavior(frame_bb_dragX, idX, data_type, p_valueX, p_minX, p_maxX, NULL,
                              ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat, &grab_bbX);
    if (value_changedX)
        ImGui::MarkItemEdited(idX);

    ImGui::RenderNavCursor(frame_bb_dragX, idX);
    ImGui::RenderFrame(frame_bb_dragX.Min, frame_bb_dragX.Max, frame_col, true, g.Style.FrameRounding);

    if (!ImGui::ItemAdd(total_bb, idY, &frame_bb_dragX, 0))
        return false;

    hovered = ImGui::ItemHoverable(frame_bb_dragY, idY, g.LastItemData.ItemFlags);

    clicked     = hovered && ImGui::IsMouseClicked(0, ImGuiInputFlags_None, idY);
    make_active = (clicked || g.NavActivateId == idY);
    if (make_active && clicked)
        ImGui::SetKeyOwner(ImGuiKey_MouseLeft, idY);

    if (make_active)
    {
        ImGui::SetActiveID(idY, window);
        ImGui::SetFocusID(idY, window);
        ImGui::FocusWindow(window);
        g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    }
    frame_col = ImGui::GetColorU32(g.ActiveId == idY ? ImGuiCol_FrameBgActive
                                   : hovered         ? ImGuiCol_FrameBgHovered
                                                     : ImGuiCol_FrameBg);

    ImGui::RenderNavCursor(frame_bb_dragY, idY);
    ImGui::RenderFrame(frame_bb_dragY.Min, frame_bb_dragY.Max, frame_col, true, g.Style.FrameRounding);

    bool value_changedYS = ImGui::SliderBehavior(
        frame_bb_dragY, idY, data_type, p_valueY, p_minY, p_maxY, NULL,
        ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat | ImGuiSliderFlags_Vertical, &grab_bbY);

    if (label_size.x > 0.0f)
        ImGui::RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y),
                          label);

    ImDrawList *pDrawList = window->DrawList;

    ImU64 s_delta_x = SubScalar(data_type, p_maxX, p_minX);
    ImU64 s_delta_y = SubScalar(data_type, p_maxY, p_minY);
    float fScaleX   = (ScalarToFloat(data_type, (ImU64 *)p_valueX) - ScalarToFloat(data_type, (ImU64 *)p_minX)) /
                    ScalarToFloat(data_type, &s_delta_x);
    float fScaleY = 1.0f - (ScalarToFloat(data_type, (ImU64 *)p_valueY) - ScalarToFloat(data_type, (ImU64 *)p_minY)) /
                               ScalarToFloat(data_type, &s_delta_y);
    ImVec2 vCursorPos((frame_bb_drag.Max.x - frame_bb_drag.Min.x) * fScaleX + frame_bb_drag.Min.x,
                      (frame_bb_drag.Max.y - frame_bb_drag.Min.y) * fScaleY + frame_bb_drag.Min.y);

    char const *formatX = ImGui::DataTypeGetInfo(data_type)->PrintFmt;
    char const *formatY = ImGui::DataTypeGetInfo(data_type)->PrintFmt;

    // if ( IsPositiveScalar( data_type, ( ImU64* )p_valueX ) )
    //{
    //	formatX = " " + formatX;
    // }
    // if ( IsPositiveScalar( data_type, ( ImU64* )p_valueY ) )
    //{
    //	formatY = " " + formatY;
    // }

    // Cursor
    pDrawList->AddCircleFilled(vCursorPos, cursor_radius, uBlue, cursor_segments);

    // Vertical Line
    if (fScaleY > 2.0f * fYLimit)
        pDrawList->AddLine(ImVec2(vCursorPos.x, frame_bb_drag.Min.y + fCursorOff),
                           ImVec2(vCursorPos.x, vCursorPos.y - fCursorOff), uOrange, line_thickness);
    if (fScaleY < 1.0f - 2.0f * fYLimit)
        pDrawList->AddLine(ImVec2(vCursorPos.x, frame_bb_drag.Max.y - fCursorOff),
                           ImVec2(vCursorPos.x, vCursorPos.y + fCursorOff), uOrange, line_thickness);

    // Horizontal Line
    if (fScaleX > 2.0f * fXLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Min.x + fCursorOff, vCursorPos.y),
                           ImVec2(vCursorPos.x - fCursorOff, vCursorPos.y), uOrange, line_thickness);
    if (fScaleX < 1.0f - 2.0f * fYLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Max.x - fCursorOff, vCursorPos.y),
                           ImVec2(vCursorPos.x + fCursorOff, vCursorPos.y), uOrange, line_thickness);

    // Borders::Right
    pDrawList->AddCircleFilled(ImVec2(frame_bb_drag.Max.x, vCursorPos.y), 2.0f, uOrange, 3);
    // Handle Right::Y
    pDrawList->AddNgonFilled(ImVec2(frame_bb_dragY.GetCenter().x, vCursorPos.y), dragY_thickness * 0.5f, uOrange, 4);
    if (fScaleY > fYLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Max.x, frame_bb_drag.Min.y),
                           ImVec2(frame_bb_drag.Max.x, vCursorPos.y - fCursorOff), uBlue, border_thickness);
    if (fScaleY < 1.0f - fYLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Max.x, frame_bb_drag.Max.y),
                           ImVec2(frame_bb_drag.Max.x, vCursorPos.y + fCursorOff), uBlue, border_thickness);
    // Borders::Top
    pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, frame_bb_drag.Min.y), 2.0f, uOrange, 3);
    if (fScaleX > fXLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Min.x, frame_bb_drag.Min.y),
                           ImVec2(vCursorPos.x - fCursorOff, frame_bb_drag.Min.y), uBlue, border_thickness);
    if (fScaleX < 1.0f - fXLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Max.x, frame_bb_drag.Min.y),
                           ImVec2(vCursorPos.x + fCursorOff, frame_bb_drag.Min.y), uBlue, border_thickness);
    // Borders::Left
    pDrawList->AddCircleFilled(ImVec2(frame_bb_drag.Min.x, vCursorPos.y), 2.0f, uOrange, 3);
    if (fScaleY > fYLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Min.x, frame_bb_drag.Min.y),
                           ImVec2(frame_bb_drag.Min.x, vCursorPos.y - fCursorOff), uBlue, border_thickness);
    if (fScaleY < 1.0f - fYLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Min.x, frame_bb_drag.Max.y),
                           ImVec2(frame_bb_drag.Min.x, vCursorPos.y + fCursorOff), uBlue, border_thickness);
    // Borders::Bottom
    pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, frame_bb_drag.Max.y), 2.0f, uOrange, 3);
    // Handle Bottom::X
    pDrawList->AddNgonFilled(ImVec2(vCursorPos.x, frame_bb_dragX.GetCenter().y), dragX_thickness * 0.5f, uOrange, 4);
    if (fScaleX > fXLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Min.x, frame_bb_drag.Max.y),
                           ImVec2(vCursorPos.x - fCursorOff, frame_bb_drag.Max.y), uBlue, border_thickness);
    if (fScaleX < 1.0f - fXLimit)
        pDrawList->AddLine(ImVec2(frame_bb_drag.Max.x, frame_bb_drag.Max.y),
                           ImVec2(vCursorPos.x + fCursorOff, frame_bb_drag.Max.y), uBlue, border_thickness);

    // Add Text
    char pBufferX[64];
    char pBufferY[64];
    ImGui::DataTypeFormatString(pBufferX, IM_ARRAYSIZE(pBufferX), data_type, p_valueX, formatX);
    ImGui::DataTypeFormatString(pBufferY, IM_ARRAYSIZE(pBufferY), data_type, p_valueY, formatY);

    ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32(ImGui::GetStyle().Colors[ImGuiCol_Text]);

    ImGui::SetWindowFontScale(0.75f);

    ImVec2 const vXSize = ImGui::CalcTextSize(pBufferX);
    ImVec2 const vYSize = ImGui::CalcTextSize(pBufferY);

    pDrawList->AddText(ImVec2(ImClamp(vCursorPos.x - vXSize.x * 0.5f, frame_bb_drag.Min.x,
                                      frame_bb_drag.Min.x + frame_bb_drag.GetWidth() - vXSize.x),
                              ImLerp(frame_bb_drag.Max.y, frame_bb_dragX.Min.y - vXSize.y, text_lerp_x)),
                       uTextCol, pBufferX);
    pDrawList->AddText(ImVec2(ImLerp(frame_bb_drag.Max.x, frame_bb_dragY.Min.x - vYSize.x, text_lerp_y),
                              ImClamp(vCursorPos.y - vXSize.y * 0.5f, frame_bb_drag.Min.y,
                                      frame_bb_drag.Min.y + frame_bb_drag.GetHeight() - vYSize.y)),
                       uTextCol, pBufferY);

    ImGui::SetWindowFontScale(1.0f);

    return value_changedX || value_changedY || value_changedXS || value_changedYS;
}

bool Slider2DFloat(char const *pLabel, float *pValueX, float *pValueY, float v_minX, float v_maxX, float v_minY,
                   float v_maxY)
{
    return Slider2DScalar(pLabel, ImGuiDataType_Float, pValueX, pValueY, &v_minX, &v_maxX, &v_minY, &v_maxY);
}

bool Slider2DInt(char const *pLabel, int *pValueX, void *pValueY, int v_minX, int v_maxX, int v_minY, int v_maxY)
{
    return Slider2DScalar(pLabel, ImGuiDataType_S32, pValueX, pValueY, &v_minX, &v_maxX, &v_minY, &v_maxY);
}

#if 0
	// TODO
	bool SliderRingScalar( char const* label, ImGuiDataType data_type, void* p_value, void* p_min, void* p_max, float v_angle_min, float v_angle_max, float v_thickness, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb )
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if ( window->SkipItems )
			return false;

		IM_ASSERT( ScalarToFloat( data_type, ( ImU64* )p_min ) < ScalarToFloat( data_type, ( ImU64* )p_max ) );

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		const ImGuiID id = window->GetID( label );
		const float w = ImGui::CalcItemWidth();

		ImVec2 label_size = ImGui::CalcTextSize( label, NULL, true );

		float downScale = 0.75f;

		const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, w ) );
		const ImRect frame_bb_drag( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w * downScale, w * downScale ) );
		const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );

		ImGui::ItemSize( total_bb, style.FramePadding.y );
		if ( !ImGui::ItemAdd( total_bb, id, &frame_bb, 0 ) )
			return false;

		bool hovered = ImGui::ItemHoverable( frame_bb_drag, id, g.LastItemData.InFlags );

		bool clicked = hovered && ImGui::IsMouseClicked( 0, ImGuiInputFlags_None, id );

		bool make_active = ( clicked || g.NavActivateId == id );
		if ( make_active && clicked )
			ImGui::SetKeyOwner( ImGuiKey_MouseLeft, id );

		if ( make_active )
		{
			ImGui::SetActiveID( id, window );
			ImGui::SetFocusID( id, window );
			ImGui::FocusWindow( window );
			g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
		}

		// Draw frame
		ImU32 frame_col = ImGui::GetColorU32( g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
		ImGui::RenderNavHighlight( frame_bb_drag, id );
		ImGui::RenderFrame( frame_bb_drag.Min, frame_bb_drag.Max, frame_col, true, g.Style.FrameRounding );

		return false;
	}

#if 0
	bool DragFloatPrecise( char const* label, float* value, float v_min, float v_max, ImGuiSliderFlags flags )
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if ( window->SkipItems )
			return false;

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		const ImGuiID id = window->GetID( label );
		const ImGuiID idP = window->GetID( id );
		const float w = ImGui::CalcItemWidth();

		const ImVec2 label_size = ImGui::CalcTextSize( label, NULL, true );
		const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, label_size.y + style.FramePadding.y * 2.0f ) );
		const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );

		float precision_block_size = 128.0f;

		const bool temp_input_allowed = ( flags & ImGuiSliderFlags_NoInput ) == 0;
		ImGui::ItemSize( total_bb, style.FramePadding.y );
		if ( !ImGui::ItemAdd( total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0 ) )
			return false;

		// Default format string when passing NULL
		const bool hovered = ImGui::ItemHoverable( frame_bb, id, g.LastItemData.InFlags );
		bool temp_input_is_active = temp_input_allowed && ImGui::TempInputIsActive( id );
		if ( !temp_input_is_active )
		{
			// Tabbing or CTRL-clicking on Drag turns it into an InputText
			const bool clicked = hovered && ImGui::IsMouseClicked( 0, ImGuiInputFlags_None, id );
			const bool double_clicked = ( hovered && g.IO.MouseClickedCount[ 0 ] == 2 && ImGui::TestKeyOwner( ImGuiKey_MouseLeft, id ) );
			const bool make_active = ( clicked || double_clicked || g.NavActivateId == id );
			if ( make_active && ( clicked || double_clicked ) )
				ImGui::SetKeyOwner( ImGuiKey_MouseLeft, id );
			if ( make_active && temp_input_allowed )
				if ( ( clicked && g.IO.KeyCtrl ) || double_clicked || ( g.NavActivateId == id && ( g.NavActivateFlags & ImGuiActivateFlags_PreferInput ) ) )
					temp_input_is_active = true;

			// (Optional) simple click (without moving) turns Drag into an InputText
			if ( g.IO.ConfigDragClickToInputText && temp_input_allowed && !temp_input_is_active )
				if ( g.ActiveId == id && hovered && g.IO.MouseReleased[ 0 ] && !ImGui::IsMouseDragPastThreshold( 0, g.IO.MouseDragThreshold * ImGui::GetIO().MouseDragThreshold ) )
				{
					g.NavActivateId = id;
					g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
					temp_input_is_active = true;
				}

			if ( make_active && !temp_input_is_active )
			{
				ImGui::SetActiveID( id, window );
				ImGui::SetFocusID( id, window );
				ImGui::FocusWindow( window );
				g.ActiveIdUsingNavDirMask = ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
			}
		}

		//float fLog = ImMax< float >( ImRound( ImAbs( ImLog( ImAbs( ImFract( *value ) ) )/ImLog( 10.0f ) ) ), 5.0f );
		//float fLog;
		//float fract = ImAbs( ImFract( *value ) );
		//if ( *value < 1.0f && fract > 0.0f )
		//	fLog = ImMax( ImAbs( ImLog( fract ) / ImLog( 10.0f ) ), 1.0f );
		//else
		//if ( *value != 0 )
		//	fLog = ImRound( ImLog( ImAbs( *value ) ) / ImLog( 10.0f ) );
		//else
		//	fLog = 1.0f;

		//int log = ( int )fLog;
		//std::string sFormat( 16, '\0' );
		//ImFormatString( &sFormat[ 0 ], 16, "%%.%df", log );

		if ( temp_input_is_active )
		{
			// Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
			const bool is_clamp_input = ( flags & ImGuiSliderFlags_AlwaysClamp ) != 0 && ( ImGui::DataTypeCompare( ImGuiDataType_Float, &v_min, &v_max ) < 0 );
			//return ImGui::TempInputScalar( frame_bb, id, label, ImGuiDataType_Float, value, sFormat.c_str(), is_clamp_input ? &v_min : NULL, is_clamp_input ? &v_max : NULL );
			return ImGui::TempInputScalar( frame_bb, id, label, ImGuiDataType_Float, value, "%.7f", is_clamp_input ? &v_min : NULL, is_clamp_input ? &v_max : NULL);
		}

		float fLog;
		if ( ImGui::IsItemActive() )
		{
			float precision_block_size_half = precision_block_size * 0.5f;
			ImVec2 bb_center = frame_bb.GetCenter();
			const ImRect drag_top_bb( ImVec2( bb_center.x - precision_block_size_half, frame_bb.Min.y - precision_block_size ),
									  ImVec2( bb_center.x + precision_block_size_half, frame_bb.Min.y ) );
			const ImRect drag_bottom_bb( ImVec2( bb_center.x - precision_block_size_half, frame_bb.Max.y ),
										 ImVec2( bb_center.x + precision_block_size_half, frame_bb.Max.y + precision_block_size ) );
			window->DrawList->AddRect( drag_top_bb.Min, drag_top_bb.Max, IM_COL32( 255, 0, 0, 255 ) );
			window->DrawList->AddRect( drag_bottom_bb.Min, drag_bottom_bb.Max, IM_COL32( 0, 255, 0, 255 ) );
			ImGui::ItemAdd( drag_top_bb, idP, NULL, ImGuiItemFlags_AllowOverlap );
			if ( ImGui::IsItemHovered() )
			{
				fLog = 10.0f;
			}
			ImGui::ItemAdd( drag_bottom_bb, idP, NULL, ImGuiItemFlags_AllowOverlap );
			if ( ImGui::IsItemHovered() )
			{
				fLog = 0.01f;
			}
		}

		// Draw frame
		const ImU32 frame_col = ImGui::GetColorU32( g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
		ImGui::RenderNavHighlight( frame_bb, id );
		ImGui::RenderFrame( frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding );

		// Drag behavior
		//const bool value_changed = ImGui::DragBehavior( id, ImGuiDataType_Float, value, fLog, &v_min, &v_max, sFormat.c_str(), 0);
		const bool value_changed = ImGui::DragBehavior( id, ImGuiDataType_Float, value, fLog, &v_min, &v_max, "%.7f", 0 );
		if ( value_changed )
			ImGui::MarkItemEdited( id );

		// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
		char value_buf[ 64 ];
		const char* value_buf_end = value_buf + ImGui::DataTypeFormatString( value_buf, IM_ARRAYSIZE( value_buf ), ImGuiDataType_Float, value, "%.7f" );
		if ( g.LogEnabled )
			ImGui::LogSetNextTextDecoration( "{", "}" );
		ImGui::RenderTextClipped( frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2( 0.5f, 0.5f ) );

		if ( label_size.x > 0.0f )
			ImGui::RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

		return value_changed;
	}
#endif
#endif

//////////////////////////////////////////////////////////////////////////
// Window Customization
//////////////////////////////////////////////////////////////////////////
void SetCurrentWindowBackgroundImage(ImTextureID id, ImVec2 imgSize, bool fixedSize, ImU32 col)
{
    // float ar = imgSize.x / imgSize.y;
    ImGuiWindow *window = ImGui::GetCurrentWindow();
    // ImDrawList* drawList = ImGui::GetBackgroundDrawList();
    ImDrawList *drawList = ImGui::GetWindowDrawList();
    ImVec2      cur      = window->InnerRect.Min;
    ImVec2      uv;
    ImVec2      winSize = ImGui::GetWindowSize();

    if (fixedSize)
    {
        uv.x = winSize.x / imgSize.x;
        uv.y = winSize.y / imgSize.y;
    }
    else
    {
        if (winSize.x > winSize.y)
        {
            if (imgSize.x > imgSize.y)
            {
                uv.x = 1.0f;
                uv.y = winSize.y / winSize.x;
            }
            else
            {
                uv.x = winSize.y / winSize.x;
                uv.y = 1.0f;
            }
        }
        else
        {
            if (imgSize.x > imgSize.y)
            {
                uv.x = winSize.x / winSize.y;
                uv.y = 1.0f;
            }
            else
            {
                uv.x = 1.0f;
                uv.y = winSize.y / winSize.x;
            }
        }
    }

    drawList->AddImageRounded(id, cur, cur + winSize, ImVec2(0.0f, 0.0f), uv, col, window->WindowRounding);
}
} // namespace ImWidgets
